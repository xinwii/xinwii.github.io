{"meta":{"title":"android开发~嘤嘤","subtitle":null,"description":"android开发工程师，学习，记录。","author":"xinwii","url":"http://www.xincc.top"},"pages":[{"title":"关于我","date":"2018-04-15T08:43:25.000Z","updated":"2018-04-15T09:07:38.370Z","comments":true,"path":"about.html","permalink":"http://www.xincc.top/about.html","excerpt":"","text":"github : https://github.com/xinwii 啥都学，目前就android敢说熟悉。。。"}],"posts":[{"title":"http状态码","slug":"前端/http状态码","date":"2018-05-19T08:18:14.000Z","updated":"2018-05-20T08:37:36.758Z","comments":true,"path":"2018/05/19/前端/http状态码/","link":"","permalink":"http://www.xincc.top/2018/05/19/前端/http状态码/","excerpt":"","text":"···200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - []：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - []：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - []：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。···","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://www.xincc.top/tags/http/"}]},{"title":"git放弃本地所有修改强制pull","slug":"java/git放弃本地所有修改强制pull","date":"2018-05-04T07:10:33.000Z","updated":"2018-05-06T08:42:00.747Z","comments":true,"path":"2018/05/04/java/git放弃本地所有修改强制pull/","link":"","permalink":"http://www.xincc.top/2018/05/04/java/git放弃本地所有修改强制pull/","excerpt":"","text":"12345//下载远程仓库最新内容，不做合并git fetch --all//指令把HEAD指向master最新版本git reset --hard origin/master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.xincc.top/tags/git/"}]},{"title":"android studio 3.1整合kotlin和databinding","slug":"android/android-studio-3-1整合kotlin和databinding","date":"2018-04-26T15:59:01.000Z","updated":"2018-05-06T08:42:00.557Z","comments":true,"path":"2018/04/26/android/android-studio-3-1整合kotlin和databinding/","link":"","permalink":"http://www.xincc.top/2018/04/26/android/android-studio-3-1整合kotlin和databinding/","excerpt":"","text":"纯原生新建，勾选kotlin，添加databingding1234567apply plugin: &apos;kotlin-kapt&apos; //只要加上这一行defaultConfig &#123; dataBinding &#123; enabled = true &#125;&#125; apply plugin: ‘kotlin-kapt’ //只要加上这一行，就编译过去了","categories":[{"name":"android","slug":"android","permalink":"http://www.xincc.top/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.xincc.top/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"http://www.xincc.top/tags/kotlin/"},{"name":"databinding","slug":"databinding","permalink":"http://www.xincc.top/tags/databinding/"}]},{"title":"ConstraintLayout笔记","slug":"android/ConstraintLayout笔记","date":"2018-01-14T12:22:54.000Z","updated":"2018-05-06T08:42:00.552Z","comments":true,"path":"2018/01/14/android/ConstraintLayout笔记/","link":"","permalink":"http://www.xincc.top/2018/01/14/android/ConstraintLayout笔记/","excerpt":"","text":"ConstraintLayout类似于RelativeLayout，主要用来做界面的操作。主要通过拖动来实现布局，基本上可以实现一层布局，提高性能。提供了layout_constraintHorizontal_weight功能，补充了RelativeLayout不足。没有match_parent,要使用0dp才行。layout_constraint[当前控件被约束属性]_[参照控件属性]=”[参照控件]”比如1app:layout_constraintLeft_toLeftOf=&quot;parent&quot; 代表当前控件的左边与父控件的左边对齐。123456app:layout_constraintLeft_toRightOf=&quot;@id/cancel_button&quot;``` 本控件的左边界与ID为cancel_button的右边界对齐``` app:layout_constraintHorizontal_bias=&quot;0.25&quot; 本控件在X轴1/4的地方开始 app:layout_constraintVertical_bias=&quot;0.25&quot; 本控件在Y轴1/4的地方开始 12app:layout_constraintLeft_toLeftOf=&quot;parent&quot;app:layout_constraintRight_toRightOf=&quot;parent&quot; 倾向（Bias） 搭配bias，能使约束偏向某一边，默认是0.5，有以下属性： layout_constraintHorizontal_bias (0最左边 1最右边) layout_constraintVertical_bias (0最上边 1 最底边) 加入app:layout_constraintHorizontal_bias=”0.9” ,则会在水平方向上向右偏移至90%。 12android:layout_marginRight=&quot;10dp&quot;app:layout_goneMarginRight=&quot;110dp&quot; 假如button1在button2右边，如果只有layout_marginRight，如果button1隐藏，button2会向右移动，margin parent为10dp，但是原来是110dp（假设button1宽度100dp），这时候就要设置layout_goneMarginRight，设置大小为layout_marginRight加上button1的宽度，layout_goneMarginRight在button1非gone状态时无作用。1app:layout_constraintDimensionRatio=&quot;4:3&quot; 设置view的宽高比 1app:layout_constraintDimensionRatio=&quot;W, 1:4&quot; 当宽和高都为match_constraint即0dp时，约束方向为x轴时(宽为parent)：w, 1:2 高比宽； h, 2:1 宽比高约束方向为y轴时(高为parent):w, 1:2 宽比高; h, 2:1 高比宽 1app:layout_constraintBaseline_toBaselineOf 基线对齐，放到控件上面，然后在控件中间偏下出现一道横线，拖动与另外一个控件的这道横线平齐。点击ab可以出现这道线，×可以删除这种约束。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.xincc.top/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.xincc.top/tags/android/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://www.xincc.top/tags/ConstraintLayout/"}]},{"title":"weex引入weex-ui报错","slug":"前端/weex引入weex-ui报错","date":"2018-01-14T12:17:34.000Z","updated":"2018-05-06T08:42:00.801Z","comments":true,"path":"2018/01/14/前端/weex引入weex-ui报错/","link":"","permalink":"http://www.xincc.top/2018/01/14/前端/weex引入weex-ui报错/","excerpt":"","text":"修改.babelrc文件为： { “presets”: [“es2015”, “stage-0”], “plugins”: [ [ “component”, { “libraryName”: “weex-ui”, “libDir”: “packages”, “style”: false } ] ] }","categories":[{"name":"weex","slug":"weex","permalink":"http://www.xincc.top/categories/weex/"}],"tags":[{"name":"weex","slug":"weex","permalink":"http://www.xincc.top/tags/weex/"}]},{"title":"安装mysql server失败","slug":"java/安装mysql server失败","date":"2017-08-14T11:22:14.000Z","updated":"2018-05-06T08:42:00.765Z","comments":true,"path":"2017/08/14/java/安装mysql server失败/","link":"","permalink":"http://www.xincc.top/2017/08/14/java/安装mysql server失败/","excerpt":"","text":"1: Action 20:48:27: INSTALL. 1: 1: MySQL Server 5.7 2: {F08E9C75-A42E-4962-8760-4CBD9CF35D7A} 1: Action 20:48:27: FindRelatedProducts. Searching for related applications 1: Action 20:48:27: AppSearch. Searching for installed applications 1: Action 20:48:27: LaunchConditions. Evaluating launch conditions 1: This application requires Visual Studio 2013 Redistributable. Please install the Redistributable then run this installer again. 1: 1: MySQL Server 5.7 2: {F08E9C75-A42E-4962-8760-4CBD9CF35D7A} 3: 3 1: The action ‘Install’ for product ‘MySQL Server 5.7.19’ failed. 注意 ： This application requires Visual Studio 2013 Redistributable. Please install the Redistributable then run this installer again. 但是安装了，发现没用，stackoverflow有人说装32位的Visual Studio 2013 Redistributable可以，一试，真行，坑货。。。。。。。。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.xincc.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.xincc.top/tags/mysql/"}]},{"title":"服务器选windows还是linux","slug":"java/服务器选windows还是linux","date":"2017-06-14T07:36:34.000Z","updated":"2018-05-06T08:42:00.769Z","comments":true,"path":"2017/06/14/java/服务器选windows还是linux/","link":"","permalink":"http://www.xincc.top/2017/06/14/java/服务器选windows还是linux/","excerpt":"","text":"买了个2G内存的阿里云服务器，windows server 2016内存占用79%，centos内存占用37%。都开启了web服务，spring boot。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://www.xincc.top/tags/windows/"},{"name":"centos","slug":"centos","permalink":"http://www.xincc.top/tags/centos/"},{"name":"服务器","slug":"服务器","permalink":"http://www.xincc.top/tags/服务器/"}]},{"title":"记录一些面试问题","slug":"java/记录一些面试问题","date":"2017-05-05T05:15:07.000Z","updated":"2018-05-06T08:42:00.773Z","comments":true,"path":"2017/05/05/java/记录一些面试问题/","link":"","permalink":"http://www.xincc.top/2017/05/05/java/记录一些面试问题/","excerpt":"","text":"1.mvc与mvp的区别 mvc view和model可以有交互，mvp不可以","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"android","slug":"android","permalink":"http://www.xincc.top/tags/android/"}]},{"title":"23种设计模式汇总整理","slug":"java/[转]23种设计模式汇总整理","date":"2017-04-24T06:08:58.000Z","updated":"2018-05-06T08:42:00.728Z","comments":true,"path":"2017/04/24/java/[转]23种设计模式汇总整理/","link":"","permalink":"http://www.xincc.top/2017/04/24/java/[转]23种设计模式汇总整理/","excerpt":"","text":"转自：https://blog.csdn.net/jason0539/article/details/44956775 设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。其实还有两类：并发型模式和线程池模式。 设计模式的六大原则：总原则－开闭原则对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 1、单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。 2、里氏替换原则（Liskov Substitution Principle）任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3、依赖倒转原则（Dependence Inversion Principle）面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 4、接口隔离原则（Interface Segregation Principle）每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5、迪米特法则（最少知道原则）（Demeter Principle）一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6、合成复用原则（Composite Reuse Principle）尽量首先使用合成/聚合的方式，而不是使用继承。 之前已经陆续整理了9种设计模式，链接如下，接下来一段时间陆续把剩余的过一遍，整理出来，理解设计模式还是很重要的。 创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式还有两类：并发型模式和线程池模式。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.xincc.top/tags/设计模式/"}]},{"title":"java交换两个变量的值","slug":"java/java交换两个变量的值","date":"2017-03-28T11:00:34.000Z","updated":"2018-05-06T08:42:00.751Z","comments":true,"path":"2017/03/28/java/java交换两个变量的值/","link":"","permalink":"http://www.xincc.top/2017/03/28/java/java交换两个变量的值/","excerpt":"","text":"[TOC] java交换两个变量的值// 1. 临时变量(推荐使用，简单直接) 123temp = a; a = b; b = temp; // 2. 异或(只支持整形,float等不支持) 123a = a ^ b; b = a ^ b; a = a ^ b; // 3. 加减法(float类型可能会导致浮点的溢出, 如a = 1.1,b = 2.2时) 123a = a + b; b = a - b; a = a - b; // 4. 临时数组(借鉴js的一种写法 —&gt; a = [b,b=a][0];)// 也可以是其他类型的数组 1a = new int[]&#123;b ,b = a&#125;[0]; // 5. 这个貌似也不错 1a = b + (b=a)*0;","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"JVM学习05-字节码执行过程和JVM指令集","slug":"java/JVM学习05-字节码执行过程和JVM指令集","date":"2017-03-26T10:00:34.000Z","updated":"2018-05-06T08:42:00.670Z","comments":true,"path":"2017/03/26/java/JVM学习05-字节码执行过程和JVM指令集/","link":"","permalink":"http://www.xincc.top/2017/03/26/java/JVM学习05-字节码执行过程和JVM指令集/","excerpt":"","text":"[TOC] JVM学习05-字节码执行过程和JVM指令集1. 字节码的Code部分在执行字节码的时候，无非也就是对调用类中的函数。那么下面将介绍下字节码函数的Code部分，Code部分的代码一个可以用java自带的命令javap命令进行查看。还可以在eclipse中安装ByteCode visualizer插件查看，具体使用自行研究。 在我介绍java内存模型的时候，函数的执行过程是分配在栈内存中的，所以在执行Code部分的时候肯定会涉及到局部变量表和操作数栈，同时还会涉及到程序计数器。之前也介绍了一个小例子，下面继续先以一个小例子讲述。 #2. 例子 源码： 12345678910package com.minosa.test;public class HelloClass &#123; public int foo()&#123; int a = 1; int b = 2; int c = a + b; return c; &#125;&#125; ByteCode visualizer查看 123456789101112131415161718192021222324252627282930313233343536public int foo() &#123; /* L6 */ 0 iconst_1; 1 istore_1; /* a */ /* L7 */ 2 iconst_2; 3 istore_2; /* b */ /* L8 */ 4 iload_1; /* a */ 5 iload_2; /* b */ 6 iadd; 7 istore_3; /* c */ /* L9 */ 8 iload_3; /* c */ 9 ireturn; /* LineNumberTable */ /* ----------+------------- */ /* start_pc | line_number */ /* ----------+------------- */ /* 0 | 6 */ /* 2 | 7 */ /* 4 | 8 */ /* 8 | 9 */ /* ----------+------------- */ /* LocalVariableTable */ /* -------+----------+--------+------------+------------------ */ /* index | start_pc | length | name_index | descriptor_index */ /* -------+----------+--------+------------+------------------ */ /* 0 | 0 | 10 | 12 | 13 */ /* 1 | 2 | 8 | 16 | 17 */ /* 2 | 4 | 6 | 18 | 17 */ /* 3 | 8 | 2 | 19 | 17 */ /* -------+----------+--------+------------+------------------ */ /* ExceptionTable (empty) */ /* max_stack: 2 max_locals: 4 */ &#125; 上面在字节码的文件结构中讲过，每个方法中存在很多属性，例如LineNumberTable，LocalVariableTable 等等。里面的一些”_index”就是指向常量池中的索引。对于成员方法来说（非类方法），局部变量表中的第一个是this（之前有讲过）。这里抽出最关键的Code进行讲述：由上面的LocalVariableTable可以知道，a变量的index是1，b是2，c是3。 12345678910111213141516public int foo() &#123; /* L6 */ 0 iconst_1; 1 istore_1; /* a */ /* L7 */ 2 iconst_2; 3 istore_2; /* b */ /* L8 */ 4 iload_1; /* a */ 5 iload_2; /* b */ 6 iadd; 7 istore_3; /* c */ /* L9 */ 8 iload_3; /* c */ 9 ireturn;&#125; 1. int a = 1;首先程序计数器值为0，iconst_1指令将整数1压入操作数栈中；执行istore_1，程序计数器为1，将操作数栈中的数弹出，然后赋值给索引为1的变量（即a）。 2. int b = 2;跟 int a = 1; 基本一致。 3. int c = a + b;这里iload指令（i表示int型，后面会列出常用的指令表）将下标为1和2，即a和b压入栈中。然后执行 idd 指令，弹出两个操作数进行相加，并将结果值压入操作数栈中。最后istore_3指令将栈中的操作数弹出并赋值给变量c。 4. return c;这里先将c的值载入压入到栈中，然后执行ireturn指令。 这里有一个很经典的面试题：就是try中的return和finally中的return，两个return的执行流程。其实看一下反汇编的指令就一目了然了。 3. JVM指令集具体的指令集可以参照博文：http://blog.csdn.net/lm2302293/article/details/6713147 里面描述了指令在字节码中对应的Byte，助记符以及功能描述，下面将对常用进行描述下。 3.1 常量入栈1. aconst_nullnull对象入栈，前面的a表示对象ref。 2. iconst_m1将 -1 压入栈中。其他的byte型和short型参照 bipush 和 sipush 指令 3. iconst_0 ~ iconst_5将整数 0 ~ 5 压入栈中。其他的byte型和short型参照 bipush 和 sipush 指令 4. lconst_1 ~ lconst_2将long类型常量 1或2 压入栈中，其他参照 ldc2_w 指令； 5. fconst_1 ~ fconst_2将float类型常量 1或2 压入栈中，其他参照 ldc 指令。 6. dconst_1 ~ dconst_1将double类型常量 1或2 压入栈中，其他参照 ldc2_w 指令。 7. bipush 和 sipushbipush将一个byte的带符号常量压入栈中，sipush将一个short型带符号常量压入栈中 8. ldc，ldc_w和ldc2_wldc 将int、float或String型常量值从常量池中压入栈中。ldc_w将int、float或String型常量值从常量池中压入栈中（宽索引）。ldc2_w将long或double型常量值从常量池中压入到栈中（宽索引）。 3.2 局部变量操作1. load（为i，l，f，d和a中一个）分别将int型，long型，float型，double型以及Object ref型的局部变量压入栈中。指令后面继续跟着_0，_1，_2，_3表示将索引为0 ~ 3的局部变量压入到栈中，大于3的索引则去掉下划线”_”，如”iload_1”，”iload 4”。 2. aload(为c，b，s，i，l，f，d和a中一个)将指定类型数组中的值压入到栈中。取值的时候先将数组的ref压入栈，然后是需要获取数据的index，然后执行*aload指令，并将获取到的值压入到栈中。这里可能会抛出数组下标越界的异常。 3. store 和 astore 指令这里基本和 load 和 aload指令类似。 3.3 通用栈操作1. nop什么都不做。 2. pop从栈顶弹出一个字长。 3. dup赋值栈顶一个字长，复制内容压入栈中。 3.4 类型转化i2c、i2b、i2s、i2l，i2f，l2i，l2f，l2d，f2i，f2d，d2i，d2l，d2f。 3.5 整数运算和浮点运算123456789101112iadd，ladd，fadd，dadd 加 +isub，lsub，fsub，dsub 减 -imul，lmul，fmul，dmul 乘 *idiv， ldiv，fdiv，ddiv 除 /irem，lrem，frem，drem 取模 %ineg，lneg，fneg，dneg 取负 -ishl，lshl 左移 &lt;&lt;ishr，lshr，iushr，lushr 有符号和无符号右移 &gt;&gt;和&gt;&gt;&gt;iand，land 按位与 &amp;ior，lor 按位或 |ixor，lxor 按位异或 ^iinc 指定int型变量增加指定的值 3.6 对象操作指令和方法调用指令1. new创建一个对象，并将引用压入栈中。 2. invokespecial 和 invokevirtual调用构造方法，私有方法 3. invokestatic 和 invokeinterface调用静态方法和接口方法 4. getstatic 和 putstaticgetstatic 获取指定类的静态域并将值压入栈中；putstatic为指定静态域赋值。 5. getfield 和 putfield同上，只是针对实例域 6. *return(return前面的*可表示为 i l f d a 或（为空return即void）） 3.7 条件控制ifeq，ifne，if_icmpeq 等等一些指令。详细见指令表。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"JVM学习04-class字节码的结构","slug":"java/JVM学习04-class字节码的结构","date":"2017-03-24T10:00:34.000Z","updated":"2018-05-06T08:42:00.664Z","comments":true,"path":"2017/03/24/java/JVM学习04-class字节码的结构/","link":"","permalink":"http://www.xincc.top/2017/03/24/java/JVM学习04-class字节码的结构/","excerpt":"","text":"[TOC] JVM学习04-class字节码的结构1. 字节码简介java作为跨平台的语言，其重要性就体现在java源代码编译后的字节码 .class 文件。很多的语言如java、groovy、scala、kotlin等都是基于JVM运行的，其根本就是输出之后的字节码。作为跨平台的一个基础，当然要对字节码的文件结构有一定的认识。 2. 字节码的文件结构字节码的文件结构一次可以分为（魔数，版本，常量池，访问符，类，超类，接口，字段，方法，属性）。每个部分的数据的大小都采用无符号整形来表示，例如u1,u2,u4等等表示一个字节，两个字节，四个字节。具体参照下图： 12345678910111213141516171819// 或者像这样ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info contant_pool[constant_pool_count – 1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; 图中的数据类型除了无符号整形之外，还有”_info”结尾的数据类型，这种称之为”表”。例如常量池中是存在多个常量的，所以要通过类似表的结构来进行存储，而且因为字节码是依次排列的，所以在描述常量池信息之前还需要对常量池中常量的个数进行描述（标记），这个很容易理解，就是用来判断什么时候读到常量池的结尾了。当然字段，方法和属性以”_info”结尾就类似了。下面对每一个部分一一描述： 在分析字节码之前介绍一款工具，Java ByteCode Editor 以下的例子基于代码（举例子的时候常量池的索引可能会存在误差，下面阅读的时候请考虑这段话）： 12345678910111213141516171819package com.minosa.test;public class HelloClass &#123; private String name = \"Mimosa\"; private int age = 20; private static final int i = 10; public String sayHello()&#123; System.out.println(\"Hello \" + name + \" ,\" + age); return name; &#125; public static void main(String[] args) &#123; int a = 1; int b = 2; int c = a + b; System.out.println(c); System.out.println(\"Hello Class !!!\"); &#125;&#125; 2.1 魔数 magic魔数是字节码固定的数值，在文件的最开始部分，占四个字节，值是 （CA FE BA BE）。 2.2 版本 version版本分为小版本minor和大版本major，分别占两个字节。例如（00 00 00 33）就表示 51.0版本。如图，稍微看下即可： 2.3 常量池 constant_pool(cp)常量池是整个字节码结构中最重要的一个部分，因为常量池之后的数据基本都是引用常量池中的数据，后面就会看到。常量池分为两个部分：cp数量和cp_info。之前说过先是以数量开头作为标识。这里解决下一个问题：为什么field_info等的数量都是fields_count，而cp_info的数量却要减1。这是因为常量池中的真实存在的数据是以下标1开始的，而下标0则代表”无引用”（不引用常量池中的任意一项），比如一个类没有接口的话就指向常量池中0下标。 常量池中的数据又存在多种类型的常量，如Class_info, Utf8_info等等，如图总表所示：类型有点多（不必害怕），依次使用例子进行描述 1. Utf8_info Utf8_info 的数据表示utf8编码中的数据，在字节码中分为三个部分：tag标识，bytes长度，bytes数据。tag表示是固定的，Utf8_info的tag值是（01），占一个字节。其次是bytes数组的length，占两个字节。最后是bytes数组中的数据，依次表示，每个字符占一个字节（中文不止一个字节，可自行研究）。比如一个类的名称（com/minosa/test/HelloClass）是个字符串，指向常量池中一个Utf8_info的数据： class字节码16进制表示中的数据（用的editplus的16进制查看器打开的）： 上图蓝色高亮部分：(1) 01 tag 表示Utf8_info类型。(2) 00 1A 表示字节数组的长度，是26(3) 63 6F 6D … 73 73，表示数组中的数据，就是字符串utf8编码的表示，这里是的数据是（com … ss）。 2. Integer_info Integer_info 数据分为两个部分：tag标识，int型值tag固定值为 03；其次是int的值，占4个字节。一般在常量池中的整形，浮点型等数据在java中是static final类型的编译时常量。比如一个static final int i = 10; 16进制字节码表示： 3. Float_info 同 Integer_info 类型，只是tag为4，数据占4个字节。 4. Long_info 同 Integer_info 类型，只是tag为5，数据占8个字节。 5. Double_info 同 Integer_info 类型，只是tag为6，数据占8个字节。 6. Class_info Class_info 表示一个类的信息，包含两个部分：tag和类全名。tag固定值为 07 ，类全名name是一个index（索引），指向一个utf8_info。如上面的类（com/minosa/test/HelloClass），表示为： 图中类的名称指向常量池中索引为2的常量，在16进制的字节码中表示为： 上图中：魔数是（CA FE BA BE），版本号是（00 00 00 33）。紧接着就是常量池：（00 46）表示常量池中数据的数量，然后就是常量池中的数据。这里的（07 00 02）就表示Class_info。 7. String_info String_info表示字符串常量，分为两个部分：tag和String值。tag固定值为 08，String的值是一个指向utf8_info的索引。比如一个面值为”Mimosa”的string常量，在常量池的表示： 在16进制字节码中的表示： 8. NameAndType_info NameAndType_info 表示名称和类型的常量，为以下Fieldref_info，Methodref_info，InterfaceMethodref_info服务。NameAndType_info 分为三个部分：tag，name和描述description。tag是固定值 0C，name就表示该类型的名称（指向utf8_info的索引），description是该类型的描述（指向utf8_info的索引）。这里的类型到后面再说，比如一个构造方法的描述： 这里的表示构造方法的描述名称，()V表示构造方法（这个后面会介绍）。16进制字节码描述： 9. Fieldref_info Fieldref_info 表示一个字段的描述，分为三个部分：tag，字段所在的Class（指向一个Class_info），字段的描述（指向一个NameAndType_info）。tag是固定值 09；其次是字段所在的类的描述；然后是字段的NameAndType描述。比如一个字段 public String name; 图中Class_info上面已经有图了，然后是NameAndType_info为： Name表示字段的名称为name，Descriptor是字段的类型为（Ljava/lang/String;），类型后面会讲到。Fieldref_info 在16进制字节码中表示： 10. Methodref_info Methodref_info 就和 Fieldref_info 同理了，分为tag，方法所在类，方法的描述三个部分。tag固定值为 0A；其次是方法所在类；最后是方法的描述；以构造方法为例： 之后的分析就和上面同理。 11. InterfaceMethodref_info 接口的方法定义，与 Methodref_info 同理。分为三个部分：tag固定值为 0B，方法所在的接口（指向一个Class_info），方法的描述（指向一个NameAndType_info）。 2.4 访问标识 access flag访问标识标识类的访问类型，占2个字节。所有类型如图： 比如当前类的访问标识为public： 2.5 本类和超类紧接着是本类和超类的，this_class和super_class都是指向常量池中的一个Class_info。比如之前的例子： 在16进制字节码中的表示： 2.6 接口 Interfaces接口与常量池类似，分为接口数量和接口描述两个部分。接口数量占用2个字节；每个接口描述是指向常量池中的一个Class_info，也占2个字节。 由于本例子中接口的数量是0，所以后面没有接口的描述。 2.7 字段 Fields字段同样分为两个部分：字段数量和字段的描述。字段数量占2个字节。每个字段描述分为5个部分：访问标识，字段名（常量池索引），字段描述（常量池索引），属性数量和属性描述。 1. 字段访问标识与类的访问标识类似，占2个字节。 2. 字段名字段的名称，指向常量池中的一个utf8_info数据。 3. 字段描述字段的描述也是指向常量池中的一个utf8_info数据。之前说类型描述后面会讲到，这里列出所有的字段类型的描述符（方法的描述符后面说）。 4. 属性数量和属性描述attributes_count 占2个字节，后面紧接着就是每个attribute_info 的描述。例如当有一个static final类型的变量，就会生成一个编译时常量Integer_info值的描述。 例子：比如name字段和age字段首先是字段的数量： 1 . private String name; name属性依次是：（00 02）表示private；（00 05和00 06）表示name和Descriptor；（00 00）表示属性的数量，这里不存在。 2 . private int age; 同上。 3 . public static final int i = 10; 然后字段有一个ConstantValue（常量）属性： 这里常量池中的#10和#11分为表示： 2.8 方法 Methods同样，方法也分为数量和方法的描述。方法的描述和字段类似，也分为：访问标识，名称，描述，属性数量和属性。 1. 访问标识占用2个字节。 2. 名称和描述名称和描述都是指向常量池中的utf8_info，各占2个字节。这里说下方法的描述符： 12345678910// 例举几个例子就明白了1. 构造方法 ==&gt; ()V表示没有参数，返回值为void2. int indexOf(char[],int) ==&gt; ([CI)I3. String name(String,long) ==&gt; (Ljava/lang/String;J)Ljava/lang/String; 3. 属性数量和属性属性的数量占2个字节。在field和method中可以有很多属性，类也存在attribute，每个attribute用于描述一个额外的信息。每个attribute又分为三个部分：attribute名称，attribute的长度和属性的描述。attribute名称是指向常量池中的一个utf8_info，占2个字节；attribute的长度占4个字节；每一个属性内容占1个字节。这里列举一些属性的描述： 例如每个方法含有Code属性，Code包含着需要执行的代码（下一博客讲述），Code属性中又含有LineNumberTable和LocalVaribleTable。LineNumberTable记录在源代码中的行号，LocalVaribleTable就表示之前博客讲过的JVM内存模型中栈中的局部变量分配的表。例如Exceptions属性表示方法申明的抛出的异常（throws的部分，非try/catch部分）。例如SourceFile表示生成该字节码的源文件名称。例如ConstantValue表示final常量的值，上面字段例举过了。 2.9 属性刚刚说了类也存在属性，那么字节码的最后一项就是类的属性。同样分为属性的数量和属性描述。例如在本例子中，存在SourceFile属性： 3. 总结其实字节码的结构还算是比较简单的，稍微过下就好。下面需要理解的就是方法中代码Code的执行过程，可以使用java自带的javap -verbose对字节码进行反汇编，查看执行的指令。理解完了字节码的执行过程，那么在此基础上可以使用ASM等字节码工具更好的对字节码进行操作。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"JVM学习03-类加载机制","slug":"java/JVM学习03-类加载机制","date":"2017-03-18T10:00:34.000Z","updated":"2018-05-06T08:42:00.658Z","comments":true,"path":"2017/03/18/java/JVM学习03-类加载机制/","link":"","permalink":"http://www.xincc.top/2017/03/18/java/JVM学习03-类加载机制/","excerpt":"","text":"[TOC] JVM学习03-类加载机制1. 类加载器简介之前有讲述过 JVM 的启动流程，在JVM找到配置文件对JVM进行初始化的时候，将会生成最基础的类加载器（c/c++语言编写）BootStrap。在说classLoader前先看一段程序： 123456789ClassLoader classLoader = this.getClass().getClassLoader();System.out.println(\"当前的ClassLoader : \" + classLoader);System.out.println(\"父ClassLoader : \" + classLoader.getParent());System.out.println(\"曾ClassLoader : \" + classLoader.getParent().getParent());// 结果：// 当前的ClassLoader : sun.misc.Launcher$AppClassLoader@2a788b76// 父ClassLoader : sun.misc.Launcher$ExtClassLoader@500c05c2// 曾ClassLoader : null 可以看出来jdk默认当前应用程序的classLoader为AppClassLoader，然后往上的父ClassLoader是ExtClassLoader，然后是null。 那么为什么最顶层的是null，这也就是BootStrap并不是java语言编写的，而是一个顶级的ClassLoader。当JVM启动Bootrap之后，Bootrap就会随之启动ExtClassLoader和AppClassLoader，并完成父子继承关系，最后由AppClassLoader加载主类的字节码，寻找到main函数进行启动。大致如图： BootStrapClassLoader：jre路径/lib/rt.jar中的字节码，或者通过 -Xbootclasspath 参数指定路径的下的字节码。 ExtClassLoader ： jre路径/lib/ext目录下 *.jar 的字节码。 AppClassLoader： 加载用户classpath下的字节码。 除了 BootStrapClassLoader 不能直接被程序员使用外，其他的类加载器都能被程序使用和修改。 2. class加载验证流程要让主类中的main函数运行，当然少不了的就是字节码（class）的加载。这个也是class装载验证流程中的第一步类加载。然后第二步是链接，最后是进行初始化。 2.1 类加载首先肯定是读取class文件的二进制流。由于Class等类的信息的存储在方法区中的，所以进而转化为方法区的数据结构，为了能够被使用，最后在java堆中生成代表这个字节码的java.lang.Class对象。 2.2 链接在链接中又分为验证，准备和解析等几个步骤。 (1)验证：验证字节码肯定是为了确保字节码的正确性，比如文件是否以0xCAFEBABE开头，版本是否正确等等。这个过程需要对字节码中的内容做大量的验证，诸如文件的格式，元数据，字节码验证，符合引用验证等等。(2)准备：之前在讲述java成员初始化一节中提到，在初始化之后首先需要对类进行加载。所以在这一步就是对类中的成员进行内存的分配。例如对于 1public static int i = 1; 先对i进行内存的分配，然后再赋上初始值为0。注意是准备阶段是0，然后准备阶段完成之后的类的初始化中，才会执行语句赋值为1。 这里在补充一个知识点：编译时常量和运行时常量。 12345678910111213public final static int i = 2;// 对于final static类型, 在准备阶段就会被赋值为2.// 因为i的值不能修改, 所以在编译的时候, i的值就已经确认了// 所以对于final修饰变量称为编译时常量.// ------- 举个面试题byte b1=1,b2=2,b3,b6; final byte b4=4,b5=6; b6=b4+b5; b3=(b1+b2); System.out.println(b3+b6);// 该题目在第四行会报错，原因是(b1 + b2) 会自动将类型提升为int型// 那为毛第三行不报错呢? 原因是b4和b5带有final类型, 编译器会立即知道他们的值，然后对b4+b5进行优化, 代码其实就变成了// b6 = 10; 所以不会报错. (3)解析：在解析阶段主要是将符号引用转换为直接引用。符号引用简单来说就是一个字符串，而这个字符串所引用内容的信息必须能够唯一标识一个类、字段和方法等。比如对于一个类的符号引用，必须给出类的全名，如java.lang.Object。而直接引用就是引用某个对象的一个指针或者地址偏移量，是一定存在的引用对象。 2.3 初始化类的初始化，包括static的初始化和非static的初始化，详细参考：java变量的初始化顺序 3. 类的加载器3.1 父类委托机制由上面的类加载器的继承结构可以看出，每个加载器都负责加载自己负责的区域。从java1.2开始，类加载的过程引入了父类委托的机制，这种机制更好的保证了java平台的安全性。原则：类的寻找是由下往上的，类的加载是由上往下的。 假设平台只有Bootstrap，ExtClassLoader和AppClassLoader三个加载器，当用户类路径下一个类如MyTest类被加载的时候，AppClassLoader首先查看该类是否已经被加载了，如果有就返回该类的字节码，否则询问父亲ExtClassLoader是否已经加载了。同样ExtClassLoader先查看是否自己已经加载了MyTest，如果有就返回，否则继续问Bootstrap。当然由于是在类路径下，Bootstrap也没有加载，也没有父亲可问。这个时候，他就会查看自己是否能够加载MyTest，当然由于在用户路径下（所以不能加载），然后告诉ExtClassLoader说我不能加载。然后同样ExtClassLoader也不能加载并告诉AppClassLoader也不能加载，最后AppClassLoader在查看该类的路径，对该类进行加载。这个就是类的寻找是由下往上的，加载是由上往下的。 实现父类委托的关键代码（ClassLoader）： 3.2 ClassLoader中的一些方法123456789101112// 载入并返回一个Classpublic Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException// 定义一个类，不公开调用, jdk提供加载字节码的唯一入口，不能覆盖// 可从磁盘读取字节码protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)// loadClass回调该方法，自定义ClassLoader的推荐做法protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException// 寻找已经加载的类protected final Class&lt;?&gt; findLoadedClass(String name) 3.3 父类委托的缺陷和解决由于类加载器父类委托的存在，就会导致父类加载器无法加载子类加载器所加载的类。换句话说，比如Java的SPI机制(Service Provider Interface )中，类的接口是定义在rt.jar包中的，而具体的实现是由指定厂商提供，是定义的AppClassLoader中的，如果rt.jar中有一个类需要返回该接口的一个实现，那么就需要加载获取AppClassLoader中这个接口实现类的字节码。按照父类委托机制，rt.jar的类加载器是无法访问子加载器加载的字节码的，那么该如何解决。这个就引入了一个线程上下文类加载器的概念，基本思想是给顶层类加载传入底层类加载器的实例。 1234// 设置线程上下文类加载器Thread.setContextClassLoader(ClassLoader cl)// 获取线程上下文类加载器Thread.getContextClassLoader() 这样，顶层的加载器通过线程的上下文就能访问到底层类加载，从而可以获取底层加载器所加载的字节码。打破这种默认的父类委托机制模式的应用如Tomcat的WebappClassLoader，OSGi的ClassLoader根据需要自由加载Class等等。由于父类委托的核心代码是在loadClass方法中实现的，所以当然也可以通过覆盖loadClass方法来打破父类委托的机制，比如： 12345678910protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // First, check if the class has already been loaded // 在findClass中实现类的定义defineClass装载 Class re=findClass(name); if(re==null)&#123; System.out.println(“无法载入类:”+name+“ 需要请求父加载器\"); return super.loadClass(name,resolve); &#125; return re;&#125; 4. 自定义类加载器通过自定义类加载器我们可以对手动生成的字节码进行加载，可以实现热部署等等一些功能。相信大家经常使用tomcat的热部署，那么关于自定义类的热部署可参照博文： 《Java Class热替换》 其他博文参考：《Java Classloader机制解析》《翻译：走出类加载器迷宫》","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"JVM学习02-GC算法与种类","slug":"java/JVM学习02-GC算法与种类","date":"2017-03-15T04:00:34.000Z","updated":"2018-05-06T08:42:00.641Z","comments":true,"path":"2017/03/15/java/JVM学习02-GC算法与种类/","link":"","permalink":"http://www.xincc.top/2017/03/15/java/JVM学习02-GC算法与种类/","excerpt":"","text":"[TOC] JVM学习02-GC算法与种类1. GC 简介GC（Garbage Collection） 是垃圾收集的简写，GC机制是java中一个比较重要的概念。java的内存管理提供了内存的分配和释放，内存处理是程序编写人员很容易出错的地方，忘记或错误的内存回收很容易导致系统的不稳定，甚至瘫痪。java的GC机制可以很好的检测对象是否超过作用域而可以达到回收的要求，从而实现自动回收垃圾对象的释放内存的目的。 其实早在很久以前（1960）就已经有了GC的概念，只是java借用这个优秀的思想，在java内存模型中，GC的工作区域主要是在堆区域和方法区，大部分都是在堆区域中。 2. GC 算法2.1 引用计数法首先呢，java并没有采用引用计数法作为GC算法，因为它有明显的缺陷。 引用计数法实现比较简单：对于一个对象A来说，只要有任何一个对象或者引用指向了A，那么A的计数器就加1，当引用失效时，引用计数器就减1，最后只要对象A的引用计数器的值为0，那么A就不可能再被使用，就可被视为垃圾。 引用计数法存在明显的缺陷，第一由于不断引用和去除引用伴随着加减法，影响性能。第二最大是问题就是很难解决循环引用的问题。 这样就会存在很多的对象无法被回收，所以JVM压根没有使用引用计数法作为GC算法。 2.2 标记-清除 标记清除（Mark-Sweep）算法是现代垃圾回收算法的基础。顾名思义，标记清除算法将垃圾清除分为两个阶段：标记和清除 标记：通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用即不可达的对象。 清除：清除所有未被标记的对象。 2.3 标记-压缩标记压缩（Mark-Compact）算法适用于存活对象比较多的场合，比如老年代。它在标记-清除算法基础上做了一些优化，标记压缩算法和标记清除算法一样，首先通过根节点标记可达的对象，然后还将所有可达的对象（存活的对象）压缩到内存一端，然后清理边界外所有空间。 标记：通过根节点标记可达的对象。 压缩：将存活的对象整理到内存一端，清理边界外所有空间。 2.4 复制算法与标记清除算法相比，复制（Copying）算法相对是一个比较高效的算法，由于涉及到存活对象的赋值，所以复制算法不适合存活对象比较多的场合（如不适合老年代）。复制算法的思想大致如下：将原有的内存分为两块空间，每次只使用其中一块，在垃圾回收的时候，将正在使用内存中存活的对象复制到未使用的内存块中，之后清除正在使用内存中的所有对象，然后交换两个内存的角色完成垃圾回收。 2.5 增量算法还有一种算法是增量算法（直接摘抄了）：增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 2.6 总结 首先是引用计数法，这个缺陷比较明显，JVM也没有采用，不做讨论。 标记清除和标记压缩相比，前者产生大量不连续的内存碎片。后者虽然不产内存碎片，但是在前者的基础上还进行对象的压缩（整理），所以成本相对较高。且两者都会进行标记和清除，效率不是很高。 复制算法虽然比较简单高效，且不会产生内存碎片，但是明显浪费了大量的内存空间 3. 分代思想根据GC算法的总结可以知道，结合不同算法的优点才能规划出一套比较可行的方案，所谓没有最好只有更好。 前面JVM内存模型中有说到将JAVA堆分为新生代和老年代，然后又将新生代细分为eden space，survivor space(分为from和to或者s0和s1)，然后根据对象的存活周期将短命对象归为新生代，长命对象归为老年代。 所以根据不同代的特点，在对象存活比较少的新生代采用复制算法，在老年代采用标记清除或标记压缩算法。 图中，在进行垃圾回收的时候，存活对象如何存放有很多种可能。 左边绿色的箭头表示在垃圾回收的时候，第一种年龄比较大的对象会存放在老年代中；第二种情况就是一些比较大的对象无法放到 survivor 空间中，那么此时大对象也被存放到老年代中，所以有时候也称老年代是一个担保空间。 左边红色和黄色的箭头就是进行正常的复制算法，垃圾回收结束就是右图的样子。 有的时候查看GC日志的时候，新生代的垃圾回收一般称为minor gc。老年代由于区域比较大且存活对象很多，生命周期很长，所以gc时候会比较长，通常称为full gc。 4. 对象的可触及性对象的可触及性顾名思义就是从根节点可以标记的对象。大家一般情况会认为对象要么是可触及的，要么是不可触及的，其实中间还存在一个可复活性。 可触及性：从根节点可以触及的对象 可复活性：一旦所有引用被释放，对象进入可复活状态，因为在 finalize() 方法后对象可能变得可触及 不可触及性：finalize() 方法之后，对象可能进入不可触及状态。不可触及的对象不能复活，然后进入可回收的状态。 这里需要注意的一点是 finalize() 方法只会被执行一次，所以某个对象不能无限从可复活性到达可触及性。而且 finalize() 方法的执行优先级很低，何时出发GC并不确定，finalize()方法的调用也变得不确定。 更详细参照：《finalize 总结》 5. Stop-The-World (STW) 现象STW现象是java的一种全局暂停的现象，所有Java代码停止运行（Native代码可以执行，但不能与JVM交互）。产生这种现象的原因多半是由于 GC 引起的。GC 为什么产生 STW 现象？这个以开 Party 打个比方：我们在开party 的时候会产生很多的垃圾，那么此时如果有人来清理垃圾，我们他在清理的时候，我们又不断产生垃圾，那么房间永远打扫不干净，所以唯一的办法就是我们停止手中的事情，直到房间打扫干净后再进行活动。 那么GC也是这个道理，当发生GC的时候，必然所有的工作线程会停止，那么此时就会产生java停顿的现象。 当发生STW现象的时候，如果时间短还好，如果时间特别长甚至几十分钟，服务器就会长时间得不到响应，那么就会带来比较大的危害。解决方法可以使用主备机的切换吧，具体不是很清楚，也不展开了。 6. 垃圾回收器的种类6.1 新生代串行收集器串行收集器是一个古老而稳定，经过长时间考验的垃圾收集器。在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。但是有的时候会停顿很长时间，且是线程独占的。 新生代串行收集器采用了复制算法，当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。 在 HotSpot 虚拟机中，使用 -XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器。此时老年代串行收集器采用的是标记-压缩算法。 1[GC 0.844: [DefNew: 17472K-&gt;2176K(19648K), 0.0188339 secs] 17472K-&gt;2375K(63360K), 0.0189186 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 6.2 老年代串行收集器老年代串行收集器和新生代串行收集器一样，老年代串行收集器采用的是标记-压缩算法，可以使用 -XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器。图解和新生代串行收集器一样。 1[Full GC 8.259: [Tenured: 43711K-&gt;40302K(43712K), 0.2960477 secs] 63350K-&gt;40302K(63360K), [Perm : 17836K-&gt;17836K(32768K)], 0.2961554 secs] [Times: user=0.28 sys=0.02, real=0.30 secs] 6.3 并行收集器并行收集器工作在新生代，仅仅是将新生代串行收集器变成了多线程化了，它的回收策略、算法以及参数和串行回收器一样。新生代依旧采用复制算法，老年代还是串行收集器（标记压缩算法）。GC依旧是线程独占的。开启并行回收器可以使用参数 -XX:+UseParNewGC 多线程并不意味着GC一定会很快，且需要多核CPU的支持才会相对提高效率。可以使用 -XX:ParallelGCThreads 限制线程数量 1[GC 0.834: [ParNew: 13184K-&gt;1600K(14784K), 0.0092203 secs] 13184K-&gt;1921K(63936K), 0.0093401 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 6.4 新生代并行回收收集器与 ParNew 类似，新生代并行回收收集器也是使用复制算法的收集器。从表面上看，它和并行收集器一样都是多线程、独占式的收集器。但是，并行回收收集器有一个重要的特点：它非常关注系统的吞吐量。使用 -XX:+UseParallelGC 设置 新生代使用Parallel收集器 + 老年代使用串行收集器使用 -XX:+UseParallelOldGC 设置 新生代和老年代都使用Parallel收集器 1[Full GC [PSYoungGen: 2682K-&gt;0K(19136K)] [ParOldGen: 28035K-&gt;30437K(43712K)] 30717K-&gt;30437K(62848K) [PSPermGen: 10943K-&gt;10928K(32768K)], 0.2902791 secs] [Times: user=1.44 sys=0.03, real=0.30 secs] 6.5 老年代并行回收收集器老年代的并行收集器和新生代并行收集器一样，所线程且关注系统吞吐量，采用标记压缩的算法。使用 -XX:+UseParallelOldGC 设置 新生代和老年代都使用Parallel收集器图解和日志清单跟新生代并行收集器一样。 这里新生代和老年代的并行收集器和使用以下参数启动： -XX:MaxGCPauseMills ： 设置最大的停顿时间，单位是毫秒。GC会尽力保证回收的时间不超过吞吐量。 -XX:GCTimeRatio ： 设置吞吐量的大小n，GC时间比[ 1/(1+n) ]。默认值为99，即最大允许1%的时间用于垃圾回收。 这两个参数本来就是矛盾的，如果将最大停顿时间设置越小，那么GC就会越频繁，从而降低整个系统的吞吐量。如果吞吐量设置越大，GC导致的停顿时间也会越长，所以有所矛盾。所以在实际中也可以采用自适应的GC调节策略，使用 -XX:+UseAdaptiveSizePolicy 可以打开自适应 GC 策略。在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。 6.6 CMS收集器CMS （Concurrent Mark Sweep）是并发标记清除的收集器，这里的并发表示可以和用户线程一起工作，且采用标记清除算法。 CMS 收集器针是老年代收集器，新生代采用 ParNew 并行收集器。可以使用 -XX:+UseConcMarkSweepGC启动 CMS 收集器。 CMS 工作大致可分为如下几个过程： 初始标记：GC 线程独占，对根可以直接关联到的对象进行标记，速度比较快。 并发标记：GC 线程和用户线程一起执行，对所有的对象进行标记。 重新标记：由于上一步并发过程，用户线程可能还会生产出垃圾，所以GC 线程独占，在正式清理前重新做一次标记。 并发清除：GC 线程和用户线程一起执行，GC 回收垃圾对象。 123456789101.662: [GC [1 CMS-initial-mark: 28122K(49152K)] 29959K(63936K), 0.0046877 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 1.666: [CMS-concurrent-mark-start]1.699: [CMS-concurrent-mark: 0.033/0.033 secs] [Times: user=0.25 sys=0.00, real=0.03 secs] 1.699: [CMS-concurrent-preclean-start]1.700: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 1.700: [GC[YG occupancy: 1837 K (14784 K)]1.700: [Rescan (parallel) , 0.0009330 secs]1.701: [weak refs processing, 0.0000180 secs] [1 CMS-remark: 28122K(49152K)] 29959K(63936K), 0.0010248 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 1.702: [CMS-concurrent-sweep-start]1.739: [CMS-concurrent-sweep: 0.035/0.037 secs] [Times: user=0.11 sys=0.02, real=0.05 secs] 1.739: [CMS-concurrent-reset-start]1.741: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] CMS虽然是并发收集器，但是其实也会存在线程独占的情况导致全局停顿，只是降低了停顿的时间罢了。由于用户线程的运行过程中，GC的时候还需要分CPU去做垃圾回收，这样就会大大降低整体系统的反应速速。在清理阶段，由于和用户线程并发执行，还会产生新的垃圾，导致清理不彻底。甚至还可能会存在产生的垃圾使得CMS来不及清理，让可使用内存的容量迅速减小，直到内存预留不够，引起 concurrent mode failure 错误。 解决方案： 第一可以通过 -XX:CMSInitiatingOccupancyFraction 的值来设置触发CMS收集器的阀值。默认为68，即当老年代空间使用率达到68%的时候触发CMS回收。第二当引起concurrent mode failure 错误的时候，JVM就会启动备用回收器 **老年代串行回收器** 作为GC回收器。 CMS收集器的一些参数： -XX:+UseCMSCompactAtFullCollection 参数将在进行一个Full GC之后进行一次内存压缩（整理），由于CMS采用的是标记清除算法。由于整理过程是线程独占的，所以可能引起的停顿时间较长。 -XX:+CMSFullGCsBeforeCompaction 参数设置多少次Full GC后进行一次内存整理。 -XX:ParallelCMSThreads 参数设置CMS线程的数量。 6.7 G1收集器G1 (Garbage-First)是一款面向服务器的垃圾收集器, 主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 在Oracle JDK 7 update 4 及以上版本中得到完全支持, 专为以下应用程序设计: 可以像CMS收集器一样, GC操作与应用的线程一起并发执行 紧凑的空闲内存区间且没有很长的GC停顿时间. 需要可预测的GC暂停耗时. 不想牺牲太多吞吐量性能. 启动后不需要请求更大的Java堆. G1的长期目标是取代CMS(Concurrent Mark-Sweep Collector, 并发标记-清除). 因为特性的不同使G1成为比CMS更好的解决方案. 一个区别是, G1是一款压缩型的收集器，G1通过有效的压缩完全避免了对细微空闲内存空间的分配, 不用依赖于regions，这不仅大大简化了收集器，而且还消除了潜在的内存碎片问题。除压缩以外，G1的垃圾收集停顿也比CMS容易估计，也允许用户自定义所希望的停顿参数(pause targets)。 详细参考博文：《G1垃圾收集器入门》 7. GC 相关的参数1. 与串行回收器相关的参数 -XX:+UseSerialGC ： 在新生代和老年代使用串行回收器。 -XX:+SuivivorRatio ： 设置 eden 区大小和 survivor 区大小的比例。8表示 两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10。 -XX:NewRatio ： 新生代和老年代（不包含永久区）的比。4 表示 新生代:老年代=1:4，即年轻代占堆的1/5。 -XX:+PretenureSizeThreshold : 设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。 -XX:MaxTenuringThreshold : 设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 2. 与并行 GC 相关的参数 -XX:+UseParNewGC : 在新生代使用并行收集器。 -XX:+UseParallelOldGC : 老年代使用并行回收收集器。 -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 -XX:GCTimeRatio : 设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 -XX:+UseAdaptiveSizePolicy : 打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 3. 与 CMS 回收器相关的参数 -XX:+UseConcMarkSweepGC : 新生代使用并行收集器，老年代使用 CMS + 串行收集器（备用收集器）。 -XX:+ParallelCMSThreads : 设定 CMS 的线程数量。 -XX:+CMSInitiatingOccupancyFraction : 设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。 -XX:+UseFullGCsBeforeCompaction : 设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 -XX:+CMSClassUnloadingEnabled : 允许对类元数据进行回收。 -XX:+CMSParallelRemarkEndable : 启用并行重标记。 -XX:CMSInitatingPermOccupancyFraction : 当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。 -XX:UseCMSInitatingOccupancyOnly : 表示只在到达阈值的时候，才进行 CMS 回收。 -XX:+CMSIncrementalMode : 使用增量模式，比较适合单 CPU。 4. 与 G1 回收器相关的参数 -XX:+UseG1GC：使用 G1 回收器。 -XX:+UnlockExperimentalVMOptions : 允许使用实验性参数。 -XX:+MaxGCPauseMills : 设置最大垃圾收集停顿时间。 -XX:+GCPauseIntervalMills : 设置停顿间隔时间。 5. 其他参数 -XX:+PrintGCDetails ： 打开显示GC日志的开关。 -XX:+DisableExplicitGC : 禁用显示 GC。 -Xloggc:Xxx.log : 设置GC的log位置和名称。 -XX:+HeapDumpOnOutOfMemoryError : 当堆内存移除出错的时候显示最后的GC日志。 -XX:HeapDumpPath=/var/log/gc/oom-${your-app-name}.hprof: dump的路径 -Xmx 和 –Xms : 设置堆内存的最大允许值和最小值，如-Xmx32M -Xms32M -XX:PermSize 和 -XX:MaxPermSize ： 设置永久代的最小初始值和最大允许值 如-XX:PermSize=64MB 和 -XX:MaxPermSize=256M。 -XX:MaxPermSize缺省值和client/server选项相关，-server选项下默认MaxPermSize为64m，-client选项下默认MaxPermSize为32m。 -Xmn ： 设置新生代大小 ， 如 -Xmn16M","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"JVM学习01-JVM内存模型","slug":"java/JVM学习01-JVM内存模型","date":"2017-03-12T05:00:34.000Z","updated":"2018-05-06T08:42:00.625Z","comments":true,"path":"2017/03/12/java/JVM学习01-JVM内存模型/","link":"","permalink":"http://www.xincc.top/2017/03/12/java/JVM学习01-JVM内存模型/","excerpt":"","text":"[TOC] JVM学习01-JVM内存模型1. JVM 简介JVM(Java Virtual Machine)是java虚拟机的缩写，JVM是一个虚构出来的计算机，并给出了一套JVM的规范。java虚拟机包括一套字节码指令、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。JVM屏蔽了与操作系统平台相关的信息，它只需要知道java文件最后生成的字节码文件，就能够将字节码生成具体与平台相关的机器指令，然后就可以在不同平台上不加修改的运行。这也是java跨平台的重要特点，一次编译，到处运行。 2. JVM 启动流程当我们执行命令 “java Xxx” 之后，JVM就开始启动进行对java字节码的执行，启动流程如下。 1. 装载环境配置 当运行java指令即java.exe后，就会获取到java的安装路径。然后通过路径去查找java.dll来确定jre的路径，最后找不到就通过java的版本来确定。确定好jre路径后，通过路径去寻找JVM.cfg文件，读取配置确定需要装载的JVM.dll。 2. 装载JVM.dll 获取到JVM.dll之后就开始对该文件的装载，而JVM.dll就是JVM的主要的实现。 3. 初始化JVM，获取JNIEnv实例 初始化JVM之后就可以通过JNI调用本地方法来获取JNIEnv的实例，而通过JNIEnv实例，我们可以调用如findClass等操作来获取需要执行的class。由于运行java实例有两种途径，一种是java -jar，还有一种是.class直接运行。通过jar运行的时候会去获取META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类，通过.class运行的话就直接获取到了class运行的主类。 4. 运行main方法 通过JNIEnv实例获取到运行的主类，最后找到main方法后进行执行。 详细参考：《JVM虚拟机的启动流程原理》 3. JVM 内存模型下面是JVM的内存模型图，稍微对网上的图进行了一下整合修改：下面对内存模型做下基本的介绍： 3.1 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，由于多个线程之间需要进程CPU的资源，所以当处于运行状态的线程需要知道下一条运行的字节码指令的时候，就需要通过程序计数器来选取，所以每个线程都需要一个独立的程序计数器，即程序计数器时线程私有的。 3.2 java虚拟机栈java栈中保存着java方法执行的内存模型，由于保存的是每个线程方法的运行时参数，所以栈是线程私有的。栈是由一系列的帧组成的（java栈有时也叫帧栈），每个方法执行的时候都会创建一个帧压入栈中，用来存储局部变量、操作数栈、动态链接、方法出口等信息。 1. 存储局部变量 局部变量包括方法的参数和方法内的变量。局部变量区被组织为以一个字长为单位、从0开始计数的数组，类型为short、byte和char的值在存入数组前要被转换成int值，而long和double在数组中占据连续的两项。这个方法又分为静态方法和实例方法： 123public static int runClassMethod(int i,long l,float f,double d,Object o,byte b) &#123; return 0; &#125; runClassMethod ： 123public int runInstanceMethod(char c,double d,short s,boolean b) &#123; return 0; &#125; runInstanceMethod ： 这里需要注意两点： 第一从图中可以明显看出，实例方法的在存储局部变量的时候明显比静态方法多了一个对自身引用的存储，这个我们在调用方法的时候能够理解，因为静态方法是不用使用this的。 第二，由于每调用一个方法就会为该线程创建一个帧，那么当我们调用方法的深度很深的时候（如递归），那么可能就会导致栈溢出（stackOverflowError）。栈的大小决定方法调用的深度（栈深度或者帧的数量），如果栈的大小是固定的，栈深度如果超过了栈最大深度，那么就会导致栈溢出（stackOverflowError）；当然如果栈的大小是可以伸缩的，在超过内存空间的时候，则抛出OutofMemoryError。我们可以通过JVM参数 -Xss参数来设置分配栈的大小。 2. 操作数栈 操作数栈和局部变量区的结构基本一样，但不是通过索引进行访问的，而是通过压栈和出栈的方式访问。操作数栈可以理解为一个计算产生值的一个临时存储区域。如当运行该方法的时候： 1234567891011121314151617public static int add(int a,int b)&#123; int c=0; c=a+b; return c;&#125;// 反编译后的指令/* 第一行代码L2 */0 iconst_0; /* 将0压入栈中 */1 istore_2; /* 弹出, 存储在局部变量2中即c中 *//* 第二行代码L3 */2 iload_0; /* 局部变量0即a压栈 */3 iload_1; /* 局部变量1即b压栈 */4 iadd; /* 弹出两个变量求和, 并将结果压入栈中*/5 istore_2; /* 弹出结果, 存储到局部变量2即c中 *//* 第三行代码L4 */6 iload_2; /* 将局部变量2即c压入栈中 */7 ireturn; /* 弹出返回 */ 运行add(100,98)的时候：从图中可以看出，操作数栈是一个数据的临时存储区域，通过压栈和出栈进行操作。 3. 其他 除了保存局部变量区和操作数栈外，Java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。 当JVM执行到需要常量池数据的指令时，它都会通过帧数据区中指向常量池的指针来访问它。 除了处理常量池解析外，帧里的数据还要处理Java方法的正常结束和异常终止。 2.1 如果是通过return正常结束，则当前栈帧从Java栈中弹出，恢复到发起调用的方法（上一层方法）的栈。如果方法有返回值，JVM会把返回值压入到发起调用方法（上一层方法）的操作数栈。 2.2 为了处理Java方法中的异常情况，帧数据区还必须保存一个对此方法异常引用表的引用。当异常抛出时，JVM运行catch块中的代码。如果没有catch，当前方法立即终止，然后JVM用帧区域数据的信息恢复发起调用的方法（上一层方法）的帧，然后再在当前的方法中重新抛出同样的异常，直到能够被当前方法或者上一层方法处理为止，不能处理则直接抛出异常。 3.3 本地方法栈直接摘抄了：本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。 3.4 java堆java堆（heap）是JVM管理内存中最大的一个部分，是线程共享的。存放着对象的实例和数组。几乎所有的对象的实例都在堆上分配内存，这里的几乎是因为还有可能存在栈上分配内存的情况。 12345栈上分配：直接将数据对象分配在栈中.1. 一般小对象（几十个Byte）,在没有逃逸的情况下, 可以直接分配在栈上2. 直接分配在栈上, 可以直接回收, 减轻GC的压力3. 大对象或逃逸对象只能分配在堆上逃逸：指不是线程私有的对象, 也被其他线程所使用到的对象. java堆是垃圾收集器管理的主要区域，有时候也被称为”GC堆(Garbage Collected Heap)”。java堆又分为新生代、老年代以及持久代，这里先不说持久态。新生代用于存放刚创建或者年经的对象；老年代存放年龄比较老的对象，譬如新生代中的对象一直没有被回收，生存时间足够长，或者对象太大新生代无法创建都会被存放到老年代中；java的新生代又可以进一步划分为eden，From Survivor（s0），To Survivor（s1）。之所以这么划分是跟GC算法息息相关的，这里只需要知道新生代被划分为这几个空间就好了。 3.5 方法区方法区（在Hotspot中常被称为永久代）中保存中虚拟机加载的类的元数据信息：如类信息、常量池、静态字段、方法等数据。这里有个概念容易让人混淆，就是方法区在物理上存储在堆中的，但是逻辑上是方法区和堆独立的。所以，有的时候堆还可以在划分出一个区域叫做Perm区域（持久代），默认为64M，持久代一般就是指方法区，JVM将方法区加载进内存之后，这些内存通常是不会被回收的。由于持久代是Hotspot中的一个概念，所以持久代在堆中还是方法区中并没有定论，最新的HotSpot也计划将其移除。这里注意一点：jdk6将String等常量信息放置在方法区中，jdk7已经移动到了堆中。但是如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收。 4. 线程工作的内存模型每一个线程都一个和主存相独立的工作内存，工作内存中存放着主存中变量值的一个拷贝（副本）。 当数据从主内存复制到工作存储时，必须出现两个动作： 第一，由主内存执行的读（read）操作； 第二，由工作内存执行的相应的load操作； 当数据从工作内存拷贝到主内存时，也出现两个操作： 第一，由工作内存执行的存储（store）操作； 第二，由主内存执行的相应的写（write）操作，每一个操作都是原子的，即执行期间不会被中断。 对于普通变量，一个线程中更新的值，不能马上反应在其他变量中。如果需要在其他线程中立即可见，需要使用 volatile 关键字。但是volatile仅仅只能保证每个线程读取的变量值是主存中最新的，但是不能保证变量的操作是原子性的。要保证线程的安全，还得使用java的同步机制。关于volatile的详细可参考其他博文。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"【转】java中的三种代理模式","slug":"java/[转]java的三种代理模式","date":"2017-03-10T05:00:34.000Z","updated":"2018-05-06T08:42:00.739Z","comments":true,"path":"2017/03/10/java/[转]java的三种代理模式/","link":"","permalink":"http://www.xincc.top/2017/03/10/java/[转]java的三种代理模式/","excerpt":"","text":"[TOC] java中的三种代理模式原文：https://www.cnblogs.com/cenyu/p/6289209.html 1. 代理模式代理(Proxy)是一种设计模式，提供了对目标对象另外的访问方式，即通过代理对象访问目标对象。这样做的好处是： 可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能. 这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法，如果需改修改，可以通过代理的方式来扩展该方法 举个例子来说明代理的作用：假设我们想邀请一位明星，那么并不是直接连接明星，而是联系明星的经纪人，来达到同样的目的。明星就是一个目标对象，他只要负责活动中的节目，而其他琐碎的事情就交给他的代理人(经纪人)来解决。就是代理思想在现实中的一个例子 用图表示如下: 代理模式的关键点是：代理对象与目标对象。代理对象是对目标对象的扩展，并会调用目标对象 2 代理模式实现2.1 静态代理静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类. 下面举个案例来解释:模拟保存动作,定义一个保存动作的接口IUserDao.java，然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口。调用的时候通过调用代理对象的方法来调用目标对象。需要注意的是，代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法 代码示例： 接口：IUserDao.java 123public interface IUserDao &#123; void save();&#125; 目标对象：UserDao.java 12345public class UserDao implements IUserDao &#123; public void save() &#123; System.out.println(\"----已经保存数据!----\"); &#125;&#125; 代理对象：UserDaoProxy.java 12345678910111213public class UserDaoProxy implements IUserDao &#123; //接收保存目标对象 private IUserDao target; public UserDaoProxy(IUserDao target)&#123; this.target=target; &#125; public void save() &#123; System.out.println(\"开始事务...\"); target.save(); //执行目标对象的方法 System.out.println(\"提交事务...\"); &#125;&#125; 测试类：App.java 1234567891011public class App &#123; public static void main(String[] args) &#123; //目标对象 UserDao target = new UserDao(); //代理对象,把目标对象传给代理对象,建立代理关系 UserDaoProxy proxy = new UserDaoProxy(target); proxy.save();//执行的是代理的方法 &#125;&#125; 静态代理总结： 可以做到在不修改目标对象的功能前提下，对目标功能扩展. 缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多。 同时,一旦接口增加方法,目标对象与代理对象都要维护. 那么如何解决静态代理中的缺点呢？答案是可以使用动态代理方式 2.2 动态代理动态代理有以下特点: 代理对象，不需要实现接口 代理对象的生成，是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型) 动态代理也叫做：JDK代理,接口代理 JDK中生成代理对象的API代理类所在包:java.lang.reflect.ProxyJDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是: 1static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h ) 注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为: ClassLoader loader: 指定当前目标对象使用类加载器,获取加载器的方法是固定的 Class&lt;?&gt;[] interfaces: 目标对象实现的接口的类型,使用泛型方式确认类型 InvocationHandler h: 事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入 代码示例：接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法 代理工厂类:ProxyFactory.java 12345678910111213141516171819202122232425262728293031/** * 创建动态代理对象 * 动态代理不需要实现接口,但是需要指定接口类型 */public class ProxyFactory&#123; //维护一个目标对象 private Object target; public ProxyFactory(Object target)&#123; this.target=target; &#125; //给目标对象生成代理对象 public Object getProxyInstance()&#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"开始事务2\"); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(\"提交事务2\"); return returnValue; &#125; &#125; ); &#125;&#125; 测试类:App.java 12345678910111213141516public class App &#123; public static void main(String[] args) &#123; // 目标对象 IUserDao target = new UserDao(); // 【原始的类型 class cn.itcast.b_dynamic.UserDao】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // class $Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); &#125;&#125; 总结：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理 2.3 Cglib代理上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理 Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现. Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截) Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉. Cglib子类代理实现方法: 需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可. 引入功能包后,就可以在内存中动态构建子类 代理的类不能为final,否则报错 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. 代码示例: 目标对象类:UserDao.java 12345public class UserDao &#123; public void save() &#123; System.out.println(\"----已经保存数据!----\"); &#125;&#125; Cglib代理工厂：ProxyFactory.java 12345678910111213141516171819202122232425262728293031323334353637/** * Cglib子类代理工厂 * 对UserDao在内存中动态构建一个子类对象 */public class ProxyFactory implements MethodInterceptor &#123; //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"开始事务...\"); //执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\"提交事务...\"); return returnValue; &#125;&#125; 测试类: 1234567891011121314151617/** * 测试类 */public class App &#123; @Test public void test()&#123; //目标对象 UserDao target = new UserDao(); //代理对象 UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.save(); &#125;&#125; 在Spring的AOP编程中: 如果加入容器的目标对象有实现接口，用JDK代理 如果目标对象没有实现接口，用Cglib代理","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"【转】Https前世今生","slug":"前端/[转]Https前世今生","date":"2017-03-02T04:22:34.000Z","updated":"2018-05-06T08:42:00.797Z","comments":true,"path":"2017/03/02/前端/[转]Https前世今生/","link":"","permalink":"http://www.xincc.top/2017/03/02/前端/[转]Https前世今生/","excerpt":"","text":"Https前世今生转自：https://mp.weixin.qq.com/s/ci-PVZzzDLq6n_0YWaC_GQ 1. 年前会议马上要过年了，公司业务上的需求也少了很多，这不，王小二他们召开了一场技术会议，盘点年前能干点啥。只见C哥写了一份清单，其中一项是全站升级https。 C哥说：https是一种趋势，但目前我们接口还是http的。appstore也一直要求使用https，从安全性以及appstore审核的角度来看，我们年前得全站升级https。有谁自告奋勇吗？ 小二想了一下：我来做吧C哥，正好了解下https。 C哥：好，小二，那你接下来研究下https，然后有时间再给我们分享下。 小二：好的C哥，保证完成！ 2. 深藏不露张三胖听说小二要做https，运维张三胖走到小二身旁。 张三胖：小二，听说你要做https? 小二：是啊，三胖哥，我们得全站升级https。你之前了解过吗？ 张三胖：哈哈，我还真了解过，升级https是个不错的主意。 小二：那太好了，三胖个，你有时间给我讲讲? 张三胖：好，我现在正好有时间，我也顺便复习下。 小二：多谢三胖哥，今中午请你吃饭啊。 3. 对称加密不足够三胖：小二，假设你用http协议给你女朋友发一封私密消息。这样有没有泄密的风险呢？ 小二：当然有了，http协议是明文传输，传输过程中的任何第三方都可以截取并篡改该明文。 三胖微微一笑：是的，我们画幅图表示下，你就知道信息被篡改多尴尬了，哈哈。 小二：啊？确实是，那这样太尴尬了。我女朋友不打死我… 三胖：其实用https就可以规避。 三胖：小二，你了解对称加密与非对称加密吗？ 小二：了解一些。对称加密就是加密与解密的秘钥是相同的。而非对称加密就是公钥加密的内容，必须用私钥才能解密，私钥加密的内容，必须用公钥才能解密。 三胖：小二了解的还挺多嘛，其实https就是利用了对称加密与非对称加密的特性。但你要注意，对称加密的速度是非对称加密速度的100倍左右。 小二：三胖哥我明白了，那你用刚才的例子给我讲讲https的原理吧。 三胖：好，就用刚才的例子。对称加密速度很快，所以你跟你女朋友的数据传输最好用对称加密。 小二：可以啊，那我跟我女朋友就先约定好一个秘钥呗？ 三胖：是的，我们再画张图表示你们的数据传输过程。 小二：是啊，胖哥，这样别人就没法截获我的信息了。 三胖：对。并且因为对称加解密的速度很快，对你们数据传输速度的影响微乎其微。但是，你怎么跟你女朋友沟通协商对称加密的秘钥呢？ 小二：这还不简单，我直接网上告诉他就可以了啊。 三胖：哈哈，不可以。你明文通过网络传输的秘钥被人截取了怎么办？ 小二：啊？确实是，别人截取秘钥后又可以篡改我的信息了。 三胖：这时候就需要用到我们的非对称加密来协商你们对称加密的秘钥了。 4. 非对称加密解忧愁 三胖：小美生成自己的公钥和私钥，通信之前，她告诉你她的公钥就可以了，公钥因为是公开的，所以可以随意的在网络中传输。 小二：这样啊，我得到小美的公钥后，然后用小美的公钥，对对称加密的密码进行非对称加密后发给小美。小美再通过她的私钥解密，小美就获取了我生成的对称加密的密码了。是不是？ 三胖：对，就是这样的。但是还有一个头疼的问题，你怎么确保你得到的就是小美的公钥呢？假设中间人给你截获篡改了呢？ 小二：嗯…这确实是个问题。中间人把他的公钥发给我，这样我就使用中间人的公钥加密我们对称加密的密码了，然后中间人再用他的私钥解密出我们对称加密的密码。这时候中间人已经截取了小美的公钥，然后再把我们对称加密的密码通过小美的公钥加密后发给小美…太可怕了，我们对称加密的秘钥就这样被窃取了。 三胖：其实抓包工具charles之所以能抓https的包，就是利用的你说的这个原理，一会我们再细说。那现在问题就变成了，你怎么确保你得到的公钥就是小美的。 小二：哎，真让人头疼… 三胖：你知道我们平时都有公证处吧？这个公证处是一个可信的结构，经他公证的东西，都是具有可信力度的。 小二：知道啊，前几天还看新闻说一个老太把他在帝都的一套房产通过公证处公证给了一个没有血缘关系的小伙呢。 三胖：那你想想，如果小美的公钥经过公证后，是不是就能证明这个公钥是小美的了呢？ 小二：当然能够证明。只是网络中存在这样的公证处吗？ 三胖：还真存在这样的公证处，我们把网络中的公证处称为CA(Certificate Authority)。不得不佩服前辈们，他们把一些可信的CA的证书都预先存在我们的电脑里了，证书包括CA的信息和CA的公钥。只要你电脑安装了系统，就安装了这些证书。来，你看看我电脑里默认安装的证书。 小二：哦哦，明白了，意思就说这些默认的CA证书是绝对可信的。 三胖：对，就是这个意思。所以，只要CA同时给小美颁发一个证书证明是小美就可以了。CA给小美颁发的证书中，含有小美的个人信息以及小美的公钥。同时，CA也会给小美颁发一个私钥。 你可以先把小美想象成百度，我们看下CA给百度颁发的证书。 小二：因为CA给小美颁发的证书中包含小美的公钥。也就是说，只要保证证书能够安全传输到我这里来就可以了。 三胖：对，现在的问题就转换成了。小美的证书如何能够安全的传输到你这里？其实，CA给小美颁发的证书中，包含【小美的信息+公钥】、以及【数字签名】。而【数字签名】的内容是：使用CA私钥加密过的【小美的信息+公钥】的hash值。 小二：哦哦，我好像明白了。CA的证书包含CA的公钥以及CA的一些信息，并且CA的证书默认存储在我的电脑里了，那我就可以使用CA的公钥进行解密操作，从而验证小美的证书是否是正确的了。 三胖：对的。我们可以使用你电脑里CA的公钥解密小美证书里的数字签名，从而得到签名的hash值。然后，你再用同样的hash算法对【小美的信息+公钥】进行hash计算。如果小美证书里签名的hash值与你自己计算出来的hash值一致，就说明这个证书确实是小美的，否则就不是小美的证书。 小二：三胖哥，我算是明白了。https还真是麻烦，但也确实保护了我的隐私。 三胖：对，有失必有得嘛！ 小二：嗯嗯。我现在通过小美的证书安全的获取了小美的公钥。那我这儿随机生成一个对称加密的秘钥，这个对称加密的秘钥再通过小美的公钥加密后，就能安全的传输给小美了。 三胖：是，小美再用他的私钥解密，就获取了你们约定的对称加密的密码了。以后，你们就可以使用对称加密来传输数据，暗送秋波了，哈哈~ 小二：三胖哥真是太厉害了，从此再也不用担心跟我女朋友聊天被恶搞了。 三胖：哈哈。你把你自己想成浏览器，把小美想成服务器。这就是整个https的传输流程。 小二：明白了，我画一下https在浏览器与服务器之间的运行流程，三胖哥你看下对不对。 三胖：不错不错，小二很厉害嘛，基本就是这个流程。 小二：没有没有，还得多谢三胖哥的指教啊，哈哈。 5. Charles抓取Https包的原理 三胖：小二，我们知道charles抓包工具能够抓取https的包，你知道这是什么原理吗？ 小二：这我还真不知道，按理说https是绝对安全的协议，内容不会被charles抓取啊。 三胖：你记不记得，使用charles抓https的包的时候，需要在你手机或电脑上安装并信任charles证书？ 小二：对对，是有这一步操作。 三胖：就是这一步操作，可以使Charles抓取你的https包。我给你画个流程图你就明白了。 小二：原来是这样，这不就是我刚才说的问题嘛。那么就说明https不是安全协议了？ 三胖：不是的。因为你安装并信任charles证书，是你自己主动的操作，也可以说是你自己主动泄密的结果。如果你不信任该charles证书，那么数据就不会被传输，连接会被直接中断。所以https还是安全的协议。 小二：我明白了，确实是这样，多谢三胖哥。 6. Happy Donehttps的原理明白了，接下来的事情自然就水到渠成了。 小二列出了接下来要做的事情： 1、向CA(公证处)申请自己网站的证书； 2、修改代码里静态资源的http链接为https链接； 3、修改ajax里面的http链接为https链接； 4、将证书部署在nginx上； 5、自测完成。 按照这个列表，小二一步步的顺利完成了。 最终，https上线完成，惬意的享受午后的阳光吧，happy done~","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"could not autowire no beans of type found spring boot","slug":"java/could not autowire no beans of type found spring boot","date":"2017-01-14T12:15:57.000Z","updated":"2018-05-06T08:42:00.744Z","comments":true,"path":"2017/01/14/java/could not autowire no beans of type found spring boot/","link":"","permalink":"http://www.xincc.top/2017/01/14/java/could not autowire no beans of type found spring boot/","excerpt":"","text":"spring boot自动装载的类总是报红，虽然不影响，但是很不舒服，看了网上的答案，一种降低报警等级，error改成warn，这肯定不行啊，还有一个face删除spring，这也不好吧，担心潜在的问题，starkoverflow看了一下，发现一个比较好的答案，就是自动装载的类加上注解@Repository 记得不是很清楚了，搞android很久了，我记得以前自动装载的类就要加这个注解的吧？不加也很正常，spring boot集成mybatis @Repositorypublic interface YourRepository","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://www.xincc.top/tags/spring-boot/"}]},{"title":"ArrayList源码分析","slug":"java/ArrayList源码分析","date":"2016-12-24T19:00:34.000Z","updated":"2018-05-06T08:42:00.587Z","comments":true,"path":"2016/12/25/java/ArrayList源码分析/","link":"","permalink":"http://www.xincc.top/2016/12/25/java/ArrayList源码分析/","excerpt":"","text":"[TOC] ArrayList源码分析ArrayList类的源码分析, 主要针对java1.6和java1.7的进行源码的分析。如果有明显的差异, 我会明确的指出, 要是实现方式基本相同, 那比较的上面就不多说废话了, 下面开始。 类中涉及到的进行维护的变量, 这里只说主要相同的部分, private transient Object[] elementData; // 维护数据的对象数组 private int size; // 维护数据元素的实际大小 下面讲述中直接用变量的名称代替. 1. 构造函数 new ArrayList() 1ArrayList list = new ArrayList(); 基本的构造函数调用上来就有不同1.6中调用了该构造方法之后, elementData 的数组大小直接被初始化为 10, 源码 1.7中没有直接初始化 elementData 的大小EMPTY_ELEMENTDATA 表示java1.7中维护的一个空数组 {} new ArrayList(int initialCapacity) 这个方法就是纯粹的将 elementData 的大小直接初始化为传入的大小 public ArrayList(Collection&lt;? extends E&gt; c) 这个没啥好说的, 就是直接将传入的集合变成 Object[] 数组然后赋值给 elementData , 再将 size 数值为数组的大小. 2. add 和 addAll 方法add 方法中涉及到一个比较重要的方法: 扩容扩容在1.6和1.7之中唯一的区别就是每次扩容的大小。在者就是1.7中多了几个大小是否越界判断的方法。 java1.6中, 每次扩容的大小是 elementData 的 3/2 倍再加 1java1.7中, 每次扩容的大小是 elementData 加上 elementData 的 1/2它们在扩容完之后再次与minCapacity(add中是size+1,addAll中是size+传入集合的元素大小) 比较大小是因为如果调用了addAll方法传入一个集合的时候, 防止扩容之后的大小仍然小于minCapacity（size+集合的大小）, 索性就直接将 minCapacity 赋值给size。 3. set 和 get 方法set和get方法中比较重要一点的方法就是对下标的大小进行校验：rangeCheck(index); 4. remove 方法1、 remove(int index) 方法中比较重要的方法就是 1System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 其实这个也是整个类中用的比较多的方法, 这个方法将原对象src中srcPos下标开始, 复制到目标对象dest的下标destPos开始, 复制length个的元素。最后在维护一下 size 的大小remove(Object o)方法其实就是获取元素的下标, 然后再次调用上述的删除方法。这里的 fastRemove(index)方法与上述的remove(int index) 方法基本一模一样, 代码重复了 2、protected void removeRange(int fromIndex, int toIndex) 方法这个方法是一个受保护的方法, 要想实现这种效果就需要调用subList方法返回一个子集合, 然后在调用clear()方法, 最后的导致的结果就是原来的list调用了removeRange的效果 123list.subList(start, end).clear();// 参考 http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected list.subList(start, end) 实际返回了一个SubList类这里的clear()方法其实就是调用了 removeRange(0,size()) 的方法, 接着看下subList类中的removeRange方法 这里,l 代表的就是原来集合, 接着隐含调用了原来集合的 removeRange 方法。但是在java1.7中对subList方法做了自己的实现,并且在自己增了加SubList内部类, 但是基本实现原理基本一致。 5. indexOf 方法 (lastIndexOf 同理) 6. 其他一些方法1.trimToSize(), 将 elementData 的大小变成实际元素的个数大小, 节省了内存空间 size() isEmpty() contains(Object 0) clear() removeAll(Collection&lt;?&gt; c) 和 retainAll(Collection&lt;?&gt; c) 方法 removeAll： 移除指定的元素集合retainAll： 保留指定的元素集合 java1.7中改变这两个方法的实现, 不在采用 AbstractCollection类 中的实现同样, java1.7中也对 listIterator() 和 iterator() 做了自己的实现, 同时增加了新的内部类。 7. 总结java1.7中的大多数方法除了多增加几个安全判断外基本和1.6没什么两样, 改变的地方如下 默认构造函数的实现不同, java1.6直接对保存的元素数组对象 Object[] 初始化大小为10; 而java1.7默认是直接将空数组{}赋值给 Object[], 并且在扩容的方法中进行大小的初始化, 但默认也是10。 java1.7和java1.6每次扩容的大小不同 java1.7对一些方法做了自己的实现,如subList(), removeAll(), retainAll() 等等,并同时实现了对应的内部类。而java1.6采用的是 AbstractCollection类 和 AbstractList类 中的实现 综上：ArrayList类的实现总体上还是比较简单的, 代码精炼(不愧是java大神们写的东西), 大家在使用这些类的过程中不妨多多去研究源码, 相信肯定会有很多的收货, 不光是在记忆上还是理解上都有一些突破。大家加油。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"源码","slug":"源码","permalink":"http://www.xincc.top/tags/源码/"}]},{"title":"java变量的初始化顺序","slug":"java/java变量的初始化顺序","date":"2016-01-15T05:00:34.000Z","updated":"2018-05-06T08:42:00.760Z","comments":true,"path":"2016/01/15/java/java变量的初始化顺序/","link":"","permalink":"http://www.xincc.top/2016/01/15/java/java变量的初始化顺序/","excerpt":"","text":"[TOC] java变量的初始化顺序假设子类B继承了父类A,当执行语句new B()或者new B(…)语句之后 1. 类的装载 (多次实例化只装载一次) (1). 首先要进行类A和B的装载(类只有在使用New调用创建的时候才会被 java类装载器装入),先装载父类A，再装载子类B 2. 静态初始化 (多次实例化只初始化一次) (1). 装载父类A后,完成静态动作(包括静态代码块和变量,它们的级别是相同的,按代码中出现的顺序初始化), 这里需要注意的是装载静态代码的时候,首先为静态变量分配内存空间,赋上默认值,但不把 = 后面的值赋给它(如果存在=后面的值),然后再按出现的顺序依次执行(包括static变量赋值和static代码块).12345// 比如这种情况也是ok的static&#123; i = 10;&#125; public static int i = 20; (2). 装载子类B后,同样完成静态动作,同父类A装载. 3. 实例化 (每次实例化都初始化) (1). 在实例化子类B之前,先要实例化父类A(包括非静态代码块和变量,它们的级别是相同的,按代码中出现的顺序初始化),这里同样需要注意的是在执行代码之前,首先为成员变量分配内存空间,赋上默认值,但不把 = 后面的值赋给它(如果存在=后面的值),然后再按出现的顺序依次执行(包括实例变量赋值和实例代码块),与static初始化类似. (2). 执行父类A的构造方法,这里如果子类B不指定,则执行父类A的默认构造方法,若父类没有默认的构造方法,则需要子类指定需要执行父类A的某个构造方法,否则编译不通过. 12345678public B() &#123;&#125;/** 如果父类有默认构造super()就等同于如下代码 */public B() &#123; super(); /** 如果父类没有默认构造super(), 则这里需要指定, 如super(...) */&#125; (3). 子类B的成员实例化,与父类A实例化类似. (4). 最后执行子类B的构造方法. 补充： 后来遇到一种情况, 存在子类方法覆盖方法的情况. 1234567891011121314151617181920212223242526272829303132public class B extends A &#123; public int i = 10; public B() &#123; System.out.println(&quot;B draw&quot;); &#125; public void draw() &#123; System.out.println(&quot;B draw &quot; + i); &#125; public static void main(String[] args) &#123; B b = new B(); b.draw(); &#125;&#125;class A &#123; public void draw() &#123; System.out.println(&quot;A draw&quot;); &#125; public A() &#123; System.out.println(&quot;begin&quot;); draw(); System.out.println(&quot;end&quot;); &#125;&#125; /* 输出是 begin B draw 0 end B draw B draw 10*/ 这里父类的构造方法调用了draw()方法, 但实际调用的是子类中的方法, 方法中访问了变量 i, 结果为0. 所以java在实例化的时候, 都已经将类(父类和子类)中的变量和方法都已经分配好了内存空间,并且变量赋值为默认值, 然后再按照上述的规则进行初始化.","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"ConcurrentHashMap源码分析","slug":"java/ConcurrentHashMap源码分析","date":"2016-01-12T05:00:34.000Z","updated":"2018-05-06T08:42:00.601Z","comments":true,"path":"2016/01/12/java/ConcurrentHashMap源码分析/","link":"","permalink":"http://www.xincc.top/2016/01/12/java/ConcurrentHashMap源码分析/","excerpt":"","text":"[TOC] ConcurrentHashMap源码分析熟悉了HashMap和HashTable，下面就来聊一聊并发问题。。以及说一说 ConcurrentHashMap的分析。 1 为什么采用ConcurrentHashMap为什么在多线程的环境下java建议使用ConcurrentHashMap呢，那么首先从HashMap和HashTable的缺点出发。 1.1 HashMap的问题首先大家大家都知道HashMap是线程不安全的，那为毛不安全呢。。不安全总的来说就出在HashMap的扩容问题上，当多个线程同时进行对扩容进行的操作的时候，那么就会引发安全的问题。该问题就会导致每个存储数据的某个链表形成环路。这样在get操作的时候，就会导致死循环。 参考：《疫苗：Java HashMap的死循环》 http://coolshell.cn/articles/9606.html 1.2 HashTable的问题HashTable中的方法都是用了synchronized关键字来保证线程安全，但是在多线程的环境下，HashTable的效率就显得十分低下。当一个线程在进行put操作的时候，其他的线程在访问HashTable的时候都必须进入阻塞状态，等待该线程方法完成。甚至最糟糕的是，当一个线程在put操作的时候，其他线程都不能进行get操作，所以多线程下效率十分低下。 2. ConcurrentHashMap简介由于HashMap和HashTable存在诸多问题，所以在多线程的环境最好采用ConcurrentHashMap。下面是ConcurrentHashMap的内部结构图。从图中可以看出ConcurrentHashMap将原来的整个Hash表又拆分成若干个部分，分别放到segments数组中。这个就需要进行二次散列进行存放数据，首先对key进行hash运算找到对应的segment，然后在进行一个hash运算找到对应的桶，最后进行获取或者存入操作。那他怎么进行线程安全操作的呢？就像这样由于存在多个segments，然后对每个segment分别进行lock和unlock的操作，譬如线程1访问的是segment1，线程2访问的是segment2，那么这两个在操作数据的时候不会发生同步阻塞的问题，这样就能够提高并发访问的效率问题。你也可以很粗糙的认为 ConcurrentHashMap将一个大的HashTable拆分成了若干个小的HashTable。 关于更详细一点的参照：《ConcurrentHashmap 解析》 http://my.oschina.net/zhenglingfei/blog/400515?fromerr=MfsX1eNM《深入分析ConcurrentHashMap》 http://ifeve.com/concurrenthashmap/","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"源码","slug":"源码","permalink":"http://www.xincc.top/tags/源码/"}]},{"title":"LinkedHashMap源码分析","slug":"java/LinkedHashMap源码分析","date":"2016-01-10T04:00:34.000Z","updated":"2018-05-06T08:42:00.679Z","comments":true,"path":"2016/01/10/java/LinkedHashMap源码分析/","link":"","permalink":"http://www.xincc.top/2016/01/10/java/LinkedHashMap源码分析/","excerpt":"","text":"[TOC] LinkedHashMap源码分析LinkedHashMap在java1.6和1.7中的源码几乎一样，就不一一比较了，这里就以1.7为例。其次LinkedHashMap是HashMap的子类，所有很多方法就直接采用HashMap中的实现，所以在研究LinkedHashMap之前首先需要搞明白HashMap的实现。 1 LinkedHashMap简介LinkedHashMap是HashMap的子类，众所周知LinkedHashMap在咋们印象中是顺序存放的，其实数据的保存还是跟HashMap的数据保存一模一样的，只不过LinkedHashMap在类中自己维护了一个指针，这个指针的实现就跟java1.6中LinkedList一样，维护了的是一个保存数据的头指针。同样这个链表是一个双向链表。 12// LinkedHashMap 的数据头指针private transient Entry&lt;K,V&gt; header; 同时还有一个属性 accessOrder，默认是false，可以通过构造方法指定 12// 这个属性如果为true，那么就会按照最近最少访问进行排序private final boolean accessOrder; 换句话说就是，如果 accessOrder为true的时候，当你访问了一个元素，那么这个元素就会排在链表的最后，以此类推。。最少访问的就在最前面，那么这个属性就是按照这种规则进行排序的。。后面会对此属性进行源码分析。 2 初始化2.1 构造函数构造函数都是采用了super来引用了HashMap中的构造方法，所以没什么难度。唯一不同就是对 accessOrder进行了赋值，这个属性构造方法默认全部是false，除非通过构造函数自己指定。 1LinkedHashMap&lt;String, String&gt; linkedMap = new LinkedHashMap&lt;String, String&gt;(16, .75f, true); 2.2 init()方法不知道大家在研究HashMap的时候，在HashMap的构造函数中有一个 init() 方法，这个方法在HashMap是空函数，但是在LinkedHashMap却得到了实现，所以在调用构造函数的同时也会调用这个init()方法。 12345// 初始化头指针void init() &#123; header = new Entry&lt;&gt;(-1, null, null, null); header.before = header.after = header;&#125; 3 操作元素3.1 添加元素LinkedHashMap在添加元素的时候内部会调用addEntry()方法，同样LinkedHashMap不仅仅要HashMap中的数据，同时还要维护自己的双向链表。 123456789101112131415161718void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 调用父类中的方法 super.addEntry(hash, key, value, bucketIndex); // Remove eldest entry if instructed, 这个下面介绍 Entry&lt;K,V&gt; eldest = header.after; if (removeEldestEntry(eldest)) &#123; removeEntryForKey(eldest.key); &#125;&#125;// 这个方法在父类中的 addEntry() 方法中调用了void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 维护自己的双向链表，将创建的数据插在头指针的前面，即整个链表的最后 e.addBefore(header); size++;&#125; 代码中很明确，在维护HashMap的数据同时也对LinkedHashMap中的双向链表数据进行了维护。这里还有一个方法 removeEldestEntry()，这个方法的参数是header后面的数据，即当前最旧的数据。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 这个方法在LinkedHashMap中使用返回false，那这个protected方法有什么意义呢？这里就有一个就有一个设计思想，比如当你设计的LinkedHashMap中最大只能存在100个元素，那么这个方法就起作用了。 12345private static final int MAX_ENTRIES = 100;// 覆盖这个方法, 当超过100个元素返回true, 然后代码中删除最旧的元素protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES;&#125; 3.2 获取元素获取元素比较简单，但是LinkedHashMap做了自己的实现。 123456789public V get(Object key) &#123; // 通过父类中的方法获取值 Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; // 这个方法 accessOrder 属性就起作用了 e.recordAccess(this); return e.value;&#125; recordAccess的方法实现是，如果 accessOrder 属性为true，那么就将当前访问过的元素删除并插入到双向链表的最后。 123456789void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; // 如果为 true 执行 if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125;&#125; 3.3 迭代元素LinkedHashMap之所以迭代出来的元素是有序的，是因为keySet()方法和entrySet()方法都做了自己的实现，虽然所有的内部类都和HashMap中一样，只不过获取的数据方式变了，LinkedHashMap是从自己的双向链表中获取的。。。具体就不再表述了，看下源码其实很简单。 4 其他方法4.1 containsValue(Object value)1public boolean containsValue(Object value) &#123;&#125; 这个方法还是考虑的很周到的，覆盖了父类中的方法，不再和HashMap中一样从Hash表中去循环迭代元素，而是从自己的双向链表中去迭代。这个就提高了访问的效率。 4.2 clear()方法不说了，太简单。 1234public void clear() &#123; super.clear(); header.before = header.after = header;&#125; 5 总结总体来说LinkedHashMap继承了HashMap，之所以有序是因为自己内部维护了一个双向链表，其他也没有就和HashMap基本类似。同样和HashMap一样的是，当学完LinkedHashMap之后，LinkedHashSet基本就没必要看了，实现大部分代码都是采用了LinkedHashMap中的实现。LinkedHashSet同样也继承自HashSet，HashSet在构造方法的参数中有一个 dummy 布尔参数，如果传入该值，那么HashSet就构造一个LinkedHashMap的实例，否则还是用HashSet自己默认的HashMap的实例。其他属于LinkedHashSet自己的代码基本没有。。。 123public LinkedHashSet() &#123; super(16, .75f, true);&#125; 123456789// 从LinkedHashSet中的super调用的, 传入了dummyHashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);&#125;// 如果不传dummy，就是HashSet自己的实现public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"源码","slug":"源码","permalink":"http://www.xincc.top/tags/源码/"}]},{"title":"Vector和Stack源码分析","slug":"java/Vector和Stack源码分析","date":"2016-01-06T04:00:34.000Z","updated":"2018-05-06T08:42:00.700Z","comments":true,"path":"2016/01/06/java/Vector和Stack源码分析/","link":"","permalink":"http://www.xincc.top/2016/01/06/java/Vector和Stack源码分析/","excerpt":"","text":"[TOC] Vector和Stack源码分析1. Vector与ArrayList作为底层都是采用动态数组作为实现基础的类，Vector和ArrayList在很多方面都是大同小异的。在阅读之前本文之前可以先阅读ArrayList的源码解析，然后Vector基本就一目了然了。说下他们的主要区别： 1. Vector里面的方法都是同步的，线程安全的。 2. Vector的扩容大小与ArrayList不同，Vector1.6和1.7中都是上一次大小的2倍。 3. Vector多了许多包含Element的方法 (Vector的子类栈Stack实际采用的是这些方法) 其次Vector比ArrayList还多了一个成员变量 capacityIncrement, 可以通过构造方法指定 123456789// 自定义的扩容增长大小, 可以通过构造方法指定大小protected int capacityIncrement; // 在扩容的时候会使用到// 1.6int newCapacity = (capacityIncrement &gt; 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2);// 1.7int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); 然后如果不指定数据数组的大小，那么就和ArrayList一样，Vector的默认大小也是10。其余与ArrayList名称相同的方法，实现上没什么大的区别。 2. Vector在java1.6和1.7Vector在1.6和1.7基本没多少大的区别，首先在初始化上也基本相同。没有像ArrayList从1.6升到1.7，在调用构造方法的时候还有一点小的改动。其次和ArrayList一样，Vector1.7将iterator()和listIterator()方法以及对应的内部类都有了自己的实现，不在采用父类中的方法。 3. 含Element的方法3.1 elements()1public Enumeration&lt;E&gt; elements() &#123;...&#125; 这个方法返回 Enumeration 接口的实现，与 iterator() 返回的 Iterator 接口实现基本一样，Enumeration 接口貌似由于方法名称太长、功能与Iterator 接口重复原因，后来建议使用Iterator 接口。。。 3.2 firstElement()和lastElement()12public synchronized E firstElement() &#123;...&#125;public synchronized E lastElement() &#123;...&#125; 顾名思义，返回第一个元素和最后一个元素，如果元素不存，则抛出 NoSuchElementException 异常 3.3 crud操作123456789101112// 获取指定索引的元素public synchronized E elementAt(int index) &#123;&#125;// 设置某个索引的元素public synchronized void setElementAt(E obj, int index) &#123;&#125;// 新增一个元素public synchronized void addElement(E obj) &#123;&#125;// 删除元素public synchronized void removeElementAt(int index) &#123;&#125;public synchronized boolean removeElement(Object obj) &#123;&#125;public synchronized void removeAllElements() &#123;&#125;// 在某个索引前插入某个元素public synchronized void insertElementAt(E obj, int index) &#123;&#125; 闻其名而知其意，内部实现与传统的add,get,remove的实现基本一样。 4. Stack栈是数据结构中一种很重要的数据结构类型。java提供了其实现Stack类。首先，Stack在java1.6和1.7源码一模一样。。Stack是Vector的子类，大部分的方法都继承于Vector，且自己类中的方法也是同步的。Stack中主要方法如下： 4.1 push往栈中插入一个元素 1234public E push(E item) &#123; addElement(item); return item;&#125; 4.2 pop从栈中弹出一个元素（删除返回），实际从Vector中数组末尾删除并返回 1234567public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj;&#125; 4.3 peek获取栈顶的元素，但不删除。 123456public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1);&#125; 4.4 empty判断栈是否为空，感觉还不如用isEmpty() 123public boolean empty() &#123; return size() == 0;&#125; 4.5 search1234567public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125; 综上：stack中的方法也是特别的简单，无非也就是取了个有意义的方法名称而已，具体实现还是沿用了Vector中的方法。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"源码","slug":"源码","permalink":"http://www.xincc.top/tags/源码/"}]},{"title":"LinkedList源码分析","slug":"java/LinkedList源码分析","date":"2016-01-05T04:00:34.000Z","updated":"2018-05-06T08:42:00.691Z","comments":true,"path":"2016/01/05/java/LinkedList源码分析/","link":"","permalink":"http://www.xincc.top/2016/01/05/java/LinkedList源码分析/","excerpt":"","text":"[TOC] LinkedList源码分析LinkedList源码分析，基于java1.6和java1.7的分析，由于1.6和1.7在实现上相差比较大，所以对于1.6的分析大家可以参考下以下的一个博文。 ########################################################################参考之前，我先对1.6实现的LinkedList做下简单的介绍。首先呢，LinkedList是基于链表的，这个大家都知道，所以源代码里面肯定维护了一个头指针（不保存数据，方便操作），但是为了检索性能和方便操作的情况下，java1.6实现了的是一个双向的链表，模型大致如下。然后其余，剩下的也就是对这个双向链表的操作罢了。由于是一个链表结构，所以也就不存在类似于ArrayList的扩容一说。。 ########################################################################http://blog.csdn.net/jzhf2012/article/details/8540543################################################################################################################################################ 1. java1.6中LinkedList方法的总结看完那位博主的讲解其实LinkedList也就那么回事，无非也就是对一个双向链表的操作。由于LinkedList提供了一些可以使其作为栈、队列、双端队列的方法，下面就对这个方法做个总结。 1.1 add/get/remove系列这个系列的获取和删除如果不存在是会抛出异常的。 1 . 普通方法 1234boolean add(E e) 和 void add(int index, E element);E set(int index, E element);E get(int index);boolean remove(Object o); 和 E remove(int index); 2 . 带first方法 1234567void addFirst(E e);E getFirst();E element(); // 实际调用了getFirst()E removeFirst();E remove(); // 实际调用了removeFirst() 3 . 带last方法 123void addLast(E e);E getLast();E removeLast(); 1.2 offer/peek/poll系列这个系列的获取和删除如果不存在则返回null 1 . 普通方法 123boolean offer(E e);E peek(); // 获取第一个E poll(); // 删除并返回第一个 2 . 带first方法 123boolean offerFirst(E e);E peekFirst();E pollFirst(); 3 . 带last方法 123boolean offerLast(E e);E peekLast();E pollLast(); 1.3 pop/push系列12void push(E e); // 实际是addFirst();E pop(); // 实际是removeFirst();不存在会抛出异常 2. java1.7分析其实要是弄明白了1.6中的LinkedList，其实1.7也没有多大的难度，无非也就是改变了实现的方式。在java1.7中，取消了header的指针，而是维护了一个first指针和一个last指针，这两个指针都是存放数据的，模型如下。这里的first就是e1元素，last就是e3元素。java1.7也取消了Entry类作为链表的载体，而采用了Node类，基本和Entry大同小异。 123456789101112private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; // 中间参数为元素，前后参数为前后指针。 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 剩下来的方法操作跟原来的也就基本差不多，无非也就是同时维护了两个指针更方便于操作罢了。。。比较1.6和1.7的源码在原理上差不多，1.7只是改变了原来的双向链表的实现方式。。。大家加油。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"源码","slug":"源码","permalink":"http://www.xincc.top/tags/源码/"}]},{"title":"HashMap源码分析","slug":"java/HashMap源码分析","date":"2015-12-31T19:00:34.000Z","updated":"2018-05-06T08:42:00.613Z","comments":true,"path":"2016/01/01/java/HashMap源码分析/","link":"","permalink":"http://www.xincc.top/2016/01/01/java/HashMap源码分析/","excerpt":"","text":"[TOC] HashMap源码分析HashMap类的源码分析,本文是基于 java1.6 和 java1.7 的源码。HashMap 是基于哈希表的Map接口的实现，主要用来提供键和值的映射操作，并且键值不能“重复”，且无序。java6和7 两个版本中如果有明显不同，我会明确标出。 1. HashMap简介1.1 结构HashMap存储结构图：从图中可以看出HashMap结合了数组和链表两种数据结构，众所周知 数组在检索的速度快，插入和删除的速度慢 链表在插入和删除的速度快，检索的速度慢 这样在取长补短的情况下产生了哈希散列表的存储方式 图中，最左边竖着的存储结构是数组，每一个格子维护一个链表，这些格子叫做 桶 。每个链表的节点在java中是一个 Entry类，维护者一对键和值。这个看起来就像将一个大的链表拆分成多个小的链表，然后将每个小链表的头放在数组中一样，至于数据应该放入在哪一个桶中那就要根据对象的 hash 值来进行计算了。 1.2 hash算法那么算出hash值（散列码）的算法就是hash算法, 由于我们需要将对象（而对象包括很多，比如数字，字符，类等等）存放到每个桶中, 那么就需要计算出一个整数，然后与桶的数量进行模运算(HashMap中不是采用取模运算)才能确定处于哪一个桶之中。那么hash算法的目的就是将这些不统一的对象统一算出一个整数(int型)。 优秀的hash算法需要从时间，空间和散列程度等等进行考虑，那么关于算法就不多多说明了。提供一个下载地址，自行研究 ///////////////////////http://download.csdn.net/detail/u013082133/9378254///////////////////////下面看看hashMap中的hash算法，1.6和1.7中的关键部分基本相同 1234567891011121314151617// 1.6, 传入的 h 是某个对象o的hashCode()方法后的值, 进行了二次散列static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;// 1.7, hashSeed默认是0, 这里仅仅多了对string的处理final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; // 同样进行的二次散列 h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; 1.3 hashCode和equals说完hash算法之后，还有一个问题就是如果最后算出来的两个对象在同一个桶中（hashCode相同或者最后的取模相同），那该如何处理（这种现象称为散列冲突）。此时就需要每个对象的equals方法出场了，所以这也是java建议在覆盖hashCode()方法同时也覆盖一下equals方法的原因。当两个对象放生散列冲突的时候，这个时候就要将该桶中链表中每个元素用equals进行比较，如果为true，那么就覆盖该元素，否则挂到链表的后面。 2. HashMap分析2.1 关键属性java1.6和1.7的属性基本一样，1.7中就多了一个空数组的定义。这个是一个性能的改善吧，就像之前ArrayList类中一样，1.6在初始化实例的就会把默认的容量直接赋值给数组；而在1.7后初始化实例的时候只会赋值一个空的数组，直到调用添加方法的时候才会去初始化容量。 12345678910111213141516171819// 1.6static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认最大容量static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认负载因子transient Entry[] table; // 链表数组transient int size; // 实际数量int threshold; // 容量的临界值final float loadFactor; //负载因子transient volatile int modCount; // 修改次数// 1.7 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;transient int size;int threshold;final float loadFactor; transient int modCount; 其次这里也对这个负载因子做一下说明：负载因子是容量和临界值的商，对于HashMap的检索性能其实是和容量，hash算法以及数据的数量有一定的关系。 如果数组容量为1，那么基本和单链表一模一样。 如果容量过大，每个桶只放一个Entry，那么和普通的数组又基本一致。 好的hash算法可以使得数据有更好的分散性 其次负载因子是数组容量进行扩容的一个依据，如果当临界值超过了负载值，那么就会对数组的容量进行扩容，一般扩容的大小是上一次的2倍。负载因子也是时间和空间的一种平衡，一般采用jdk的默认0.75f就好了。 2.2 构造函数java1.6中调用了默认构造函数之后，会初始化负载因子，临界值和链表数组 123456public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // 0.75f threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 16 * 0.75 = 12 table = new Entry[DEFAULT_INITIAL_CAPACITY]; // 链表数组大小16 init(); // 空的函数, 估计为以后java版本更新提供 &#125; 而在1.7中，临界值和链表数组大小都是在调用了put方法之后进行初始化的注意：要是调用了其他构造方法，如自己传入一个默认的容量，那么java会寻找这个数字的最近2次幂来作为默认容量 1234// Find a power of 2 &gt;= initialCapacityint capacity = 1;while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; 2.3 put(K key, V value)1.6和1.7的两个方法基本一样，除了1.7中多了个初始化。 1234// 1.7中的 inflateTable 与1.6的初始化过程基本类似if (table == EMPTY_TABLE) &#123; inflateTable(threshold);&#125; 下面说一下put方法的逻辑： 1. 插入null键 （首先这个是与HashTable的一个区别，HashMap支持key为null, 当然HashTable也不支持null值）null键的这个Entry是插入在table(链表数组的0下标位置)，代码是先判断该链表上有没有null键对应的Entry，如果有就替换，否则添加到链表头。addEntry(…)方法中，做了两个操作：1. 添加数据（这里是添加到链表头），2. 是否扩容（扩容的大小是上次的两倍）这里数据的添加是将当前数据作为链表的头，然后将当前Entry的下一个指针指向原先的头。这里扩容的判断上面java1.6和1.7又有点不一样，1.7中多了对当前桶的头Entry进行null判断。这就会导致在1.6中如果默认情况下，当前的size大于了临界值就会对数组进行扩容，但是在1.7中如果当前桶的头Entry不是null的情况下才会进行扩容(后来看了下java8的源码，在判断上面又把1.7多余的这个null判断取消掉了。。。无语中)。反正不管怎么样，肯定是要根据当前实际size和临界值threshold的大小进行数组的扩容的。这里建议大家去读一读这里的源代码，就不黏贴了。。在这里的Entry拷贝上面进行的判断和内存的释放逻辑上简直让我觉得代码写的好严谨。。。 2. 插入非null键 首先算出hash值（HashMap的hash算法在上面黏贴了），然后在求出所在桶的索引位置 12345// 根据求出的hash值和数组容量大小-1进行与运算, 保证返回值始终小于length-1// 这里讲下HashTable中的实现是采用取模运算的, 没有这种位运算效率高static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 然后下面的处理就跟null键插入的逻辑基本一样，这里应该注意一个设计思想，就是大家在以后替换某个元素的时候，记得把旧的元素返回出去，以防止被调用者使用。putAll()也没啥好讲的，基本就是扩容的区别上，其次就是将数据一个个调用put()方法。 2.4 get(Object key)这里get方法同样也分为取null的key和非null的key之分。感觉也没啥好讲的，随便看下源码就一目了然了。基本思路：获取hash值，获取桶位置，桶中的链表，判断Entry的保存的hash值，key值使用相同，都一致返回value，否则返回null。 2.5 remove(Object key)remove方法的基本思路和get差不多，无非也就是获取对应key的value后进行链表中数据的删除罢了。。。就是移动指针进行删除，最后将删除的值返回出去。 2.6 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()1234private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet());&#125; 这里返回的entrySet始终是一个实例，所以在调用HashMap的put和remove等方法后，会改变entrySet实例。继续跟踪new EntrySet(), EntrySet这个类继承了AbstractSet类，实现了iterator()等方法，所以当我们调用iterator()的时候返回一个迭代器。调用之后实际调用newEntryIterator()，返回new EntryIterator()。然后迭代的时候调用hasNext()和next()，当调用next()方法的时候实际调用nextEntry()，这里面的逻辑其实就跟一般的迭代相差不大。EntryIterator类是HashIterator的子类，调用EntryIterator类的next()方法其实是调用了父类中的nextEntry()方法，感觉有一种静态代理的感觉。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; Entry&lt;K,V&gt; next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot Entry&lt;K,V&gt; current; // current entry // 初始化 HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; // 判断是否有下一个 public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; 2.7 Set&lt;K&gt; keySet()熟悉上面的entrySet()方法之后，keySet()方法其实就是回去上面的Entry然后再返回一个key罢了，是基于entrySet()方法的一个实现。这里需要注意的是，keySet()返回的实例和entrySet()一样，也是只有一个实例，所以对HashMap的put，remove等操作之后，也会改变这个实例。 2.8 杂鱼方法剩余的size()，isEmpty()，containsKey(Object key)，containsValue(Object value)就不说了，实现也是比较简单的。。 3. 总结 总体上java1.6和1.7基本没什么大的差异，比较集合分析来看，1.7在实例的初始化上采用类似懒汉的方式，不是一开始就是初始化维护数据的数组的大小，而是在调用方法的时候进行初始化。其余就是一些算法上的优化吧。 学完HashMap，基本HashTable也就基本ok了，与HashTable的不同就不详细总结了，大家自行百度。。有几个说下： (1) HashTable大多数方法都是同步的，HashMap不是。 (2) HashMap支持空的key和空的value，HashTable不支持。 (3) HashMap没有了contains(Object o)方法 一个比较好的消息就是学完HashMap之后，HashSet类基本上就不用看了，实现90%的代码采用了HashMap类的方法。。。HashSet其实就是将值存储在HashMap的key中，所以有用的代码100行都不到。。。。 最后读一读源码可以在理解是豁然开朗，大家加油。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"},{"name":"源码","slug":"源码","permalink":"http://www.xincc.top/tags/源码/"}]}]}
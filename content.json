{"meta":{"title":"android开发~嘤嘤","subtitle":null,"description":"android开发工程师，学习，记录。","author":"xinwii","url":"http://www.xincc.top"},"pages":[{"title":"about","date":"2018-04-15T08:43:25.000Z","updated":"2018-04-15T08:56:20.148Z","comments":true,"path":"about.html","permalink":"http://www.xincc.top/about.html","excerpt":"","text":"啥都学，目前就android敢说熟悉。。。"}],"posts":[{"title":"ConstraintLayout笔记","slug":"ConstraintLayout笔记","date":"2018-01-14T12:22:54.000Z","updated":"2018-04-15T08:05:54.325Z","comments":true,"path":"2018/01/14/ConstraintLayout笔记/","link":"","permalink":"http://www.xincc.top/2018/01/14/ConstraintLayout笔记/","excerpt":"","text":"ConstraintLayout类似于RelativeLayout，主要用来做界面的操作。主要通过拖动来实现布局，基本上可以实现一层布局，提高性能。提供了layout_constraintHorizontal_weight功能，补充了RelativeLayout不足。没有match_parent,要使用0dp才行。layout_constraint[当前控件被约束属性]_[参照控件属性]=”[参照控件]”比如1app:layout_constraintLeft_toLeftOf=&quot;parent&quot; 代表当前控件的左边与父控件的左边对齐。123456app:layout_constraintLeft_toRightOf=&quot;@id/cancel_button&quot;``` 本控件的左边界与ID为cancel_button的右边界对齐``` app:layout_constraintHorizontal_bias=&quot;0.25&quot; 本控件在X轴1/4的地方开始 app:layout_constraintVertical_bias=&quot;0.25&quot; 本控件在Y轴1/4的地方开始 12app:layout_constraintLeft_toLeftOf=&quot;parent&quot;app:layout_constraintRight_toRightOf=&quot;parent&quot; 倾向（Bias） 搭配bias，能使约束偏向某一边，默认是0.5，有以下属性： layout_constraintHorizontal_bias (0最左边 1最右边) layout_constraintVertical_bias (0最上边 1 最底边) 加入app:layout_constraintHorizontal_bias=”0.9” ,则会在水平方向上向右偏移至90%。 12android:layout_marginRight=&quot;10dp&quot;app:layout_goneMarginRight=&quot;110dp&quot; 假如button1在button2右边，如果只有layout_marginRight，如果button1隐藏，button2会向右移动，margin parent为10dp，但是原来是110dp（假设button1宽度100dp），这时候就要设置layout_goneMarginRight，设置大小为layout_marginRight加上button1的宽度，layout_goneMarginRight在button1非gone状态时无作用。1app:layout_constraintDimensionRatio=&quot;4:3&quot; 设置view的宽高比 1app:layout_constraintDimensionRatio=&quot;W, 1:4&quot; 当宽和高都为match_constraint即0dp时，约束方向为x轴时(宽为parent)：w, 1:2 高比宽； h, 2:1 宽比高约束方向为y轴时(高为parent):w, 1:2 宽比高; h, 2:1 高比宽 1app:layout_constraintBaseline_toBaselineOf 基线对齐，放到控件上面，然后在控件中间偏下出现一道横线，拖动与另外一个控件的这道横线平齐。点击ab可以出现这道线，×可以删除这种约束。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.xincc.top/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://www.xincc.top/tags/android/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://www.xincc.top/tags/ConstraintLayout/"}]},{"title":"weex引入weex-ui报错","slug":"weex引入weex-ui报错","date":"2018-01-14T12:17:34.000Z","updated":"2018-04-14T12:19:06.864Z","comments":true,"path":"2018/01/14/weex引入weex-ui报错/","link":"","permalink":"http://www.xincc.top/2018/01/14/weex引入weex-ui报错/","excerpt":"","text":"修改.babelrc文件为： { “presets”: [“es2015”, “stage-0”], “plugins”: [ [ “component”, { “libraryName”: “weex-ui”, “libDir”: “packages”, “style”: false } ] ] }","categories":[{"name":"weex","slug":"weex","permalink":"http://www.xincc.top/categories/weex/"}],"tags":[{"name":"weex","slug":"weex","permalink":"http://www.xincc.top/tags/weex/"}]},{"title":"安装mysql server失败","slug":"安装mysql server失败","date":"2017-08-14T11:22:14.000Z","updated":"2018-04-14T11:26:10.073Z","comments":true,"path":"2017/08/14/安装mysql server失败/","link":"","permalink":"http://www.xincc.top/2017/08/14/安装mysql server失败/","excerpt":"","text":"1: Action 20:48:27: INSTALL. 1: 1: MySQL Server 5.7 2: {F08E9C75-A42E-4962-8760-4CBD9CF35D7A} 1: Action 20:48:27: FindRelatedProducts. Searching for related applications 1: Action 20:48:27: AppSearch. Searching for installed applications 1: Action 20:48:27: LaunchConditions. Evaluating launch conditions 1: This application requires Visual Studio 2013 Redistributable. Please install the Redistributable then run this installer again. 1: 1: MySQL Server 5.7 2: {F08E9C75-A42E-4962-8760-4CBD9CF35D7A} 3: 3 1: The action ‘Install’ for product ‘MySQL Server 5.7.19’ failed. 注意 ： This application requires Visual Studio 2013 Redistributable. Please install the Redistributable then run this installer again. 但是安装了，发现没用，stackoverflow有人说装32位的Visual Studio 2013 Redistributable可以，一试，真行，坑货。。。。。。。。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.xincc.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.xincc.top/tags/mysql/"}]},{"title":"服务器选windows还是linux","slug":"服务器选windows还是linux","date":"2017-06-14T07:36:34.000Z","updated":"2018-04-14T12:21:34.996Z","comments":true,"path":"2017/06/14/服务器选windows还是linux/","link":"","permalink":"http://www.xincc.top/2017/06/14/服务器选windows还是linux/","excerpt":"","text":"买了个2G内存的阿里云服务器，windows server 2016内存占用79%，centos内存占用37%。都开启了web服务，spring boot。","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://www.xincc.top/tags/windows/"},{"name":"centos","slug":"centos","permalink":"http://www.xincc.top/tags/centos/"},{"name":"服务器","slug":"服务器","permalink":"http://www.xincc.top/tags/服务器/"}]},{"title":"【转】Https前世今生","slug":"[转]Https前世今生","date":"2017-03-02T04:22:34.000Z","updated":"2018-04-14T12:58:07.427Z","comments":true,"path":"2017/03/02/[转]Https前世今生/","link":"","permalink":"http://www.xincc.top/2017/03/02/[转]Https前世今生/","excerpt":"","text":"Https前世今生转自：https://mp.weixin.qq.com/s/ci-PVZzzDLq6n_0YWaC_GQ 1. 年前会议马上要过年了，公司业务上的需求也少了很多，这不，王小二他们召开了一场技术会议，盘点年前能干点啥。只见C哥写了一份清单，其中一项是全站升级https。 C哥说：https是一种趋势，但目前我们接口还是http的。appstore也一直要求使用https，从安全性以及appstore审核的角度来看，我们年前得全站升级https。有谁自告奋勇吗？ 小二想了一下：我来做吧C哥，正好了解下https。 C哥：好，小二，那你接下来研究下https，然后有时间再给我们分享下。 小二：好的C哥，保证完成！ 2. 深藏不露张三胖听说小二要做https，运维张三胖走到小二身旁。 张三胖：小二，听说你要做https? 小二：是啊，三胖哥，我们得全站升级https。你之前了解过吗？ 张三胖：哈哈，我还真了解过，升级https是个不错的主意。 小二：那太好了，三胖个，你有时间给我讲讲? 张三胖：好，我现在正好有时间，我也顺便复习下。 小二：多谢三胖哥，今中午请你吃饭啊。 3. 对称加密不足够三胖：小二，假设你用http协议给你女朋友发一封私密消息。这样有没有泄密的风险呢？ 小二：当然有了，http协议是明文传输，传输过程中的任何第三方都可以截取并篡改该明文。 三胖微微一笑：是的，我们画幅图表示下，你就知道信息被篡改多尴尬了，哈哈。 小二：啊？确实是，那这样太尴尬了。我女朋友不打死我… 三胖：其实用https就可以规避。 三胖：小二，你了解对称加密与非对称加密吗？ 小二：了解一些。对称加密就是加密与解密的秘钥是相同的。而非对称加密就是公钥加密的内容，必须用私钥才能解密，私钥加密的内容，必须用公钥才能解密。 三胖：小二了解的还挺多嘛，其实https就是利用了对称加密与非对称加密的特性。但你要注意，对称加密的速度是非对称加密速度的100倍左右。 小二：三胖哥我明白了，那你用刚才的例子给我讲讲https的原理吧。 三胖：好，就用刚才的例子。对称加密速度很快，所以你跟你女朋友的数据传输最好用对称加密。 小二：可以啊，那我跟我女朋友就先约定好一个秘钥呗？ 三胖：是的，我们再画张图表示你们的数据传输过程。 小二：是啊，胖哥，这样别人就没法截获我的信息了。 三胖：对。并且因为对称加解密的速度很快，对你们数据传输速度的影响微乎其微。但是，你怎么跟你女朋友沟通协商对称加密的秘钥呢？ 小二：这还不简单，我直接网上告诉他就可以了啊。 三胖：哈哈，不可以。你明文通过网络传输的秘钥被人截取了怎么办？ 小二：啊？确实是，别人截取秘钥后又可以篡改我的信息了。 三胖：这时候就需要用到我们的非对称加密来协商你们对称加密的秘钥了。 4. 非对称加密解忧愁 三胖：小美生成自己的公钥和私钥，通信之前，她告诉你她的公钥就可以了，公钥因为是公开的，所以可以随意的在网络中传输。 小二：这样啊，我得到小美的公钥后，然后用小美的公钥，对对称加密的密码进行非对称加密后发给小美。小美再通过她的私钥解密，小美就获取了我生成的对称加密的密码了。是不是？ 三胖：对，就是这样的。但是还有一个头疼的问题，你怎么确保你得到的就是小美的公钥呢？假设中间人给你截获篡改了呢？ 小二：嗯…这确实是个问题。中间人把他的公钥发给我，这样我就使用中间人的公钥加密我们对称加密的密码了，然后中间人再用他的私钥解密出我们对称加密的密码。这时候中间人已经截取了小美的公钥，然后再把我们对称加密的密码通过小美的公钥加密后发给小美…太可怕了，我们对称加密的秘钥就这样被窃取了。 三胖：其实抓包工具charles之所以能抓https的包，就是利用的你说的这个原理，一会我们再细说。那现在问题就变成了，你怎么确保你得到的公钥就是小美的。 小二：哎，真让人头疼… 三胖：你知道我们平时都有公证处吧？这个公证处是一个可信的结构，经他公证的东西，都是具有可信力度的。 小二：知道啊，前几天还看新闻说一个老太把他在帝都的一套房产通过公证处公证给了一个没有血缘关系的小伙呢。 三胖：那你想想，如果小美的公钥经过公证后，是不是就能证明这个公钥是小美的了呢？ 小二：当然能够证明。只是网络中存在这样的公证处吗？ 三胖：还真存在这样的公证处，我们把网络中的公证处称为CA(Certificate Authority)。不得不佩服前辈们，他们把一些可信的CA的证书都预先存在我们的电脑里了，证书包括CA的信息和CA的公钥。只要你电脑安装了系统，就安装了这些证书。来，你看看我电脑里默认安装的证书。 小二：哦哦，明白了，意思就说这些默认的CA证书是绝对可信的。 三胖：对，就是这个意思。所以，只要CA同时给小美颁发一个证书证明是小美就可以了。CA给小美颁发的证书中，含有小美的个人信息以及小美的公钥。同时，CA也会给小美颁发一个私钥。 你可以先把小美想象成百度，我们看下CA给百度颁发的证书。 小二：因为CA给小美颁发的证书中包含小美的公钥。也就是说，只要保证证书能够安全传输到我这里来就可以了。 三胖：对，现在的问题就转换成了。小美的证书如何能够安全的传输到你这里？其实，CA给小美颁发的证书中，包含【小美的信息+公钥】、以及【数字签名】。而【数字签名】的内容是：使用CA私钥加密过的【小美的信息+公钥】的hash值。 小二：哦哦，我好像明白了。CA的证书包含CA的公钥以及CA的一些信息，并且CA的证书默认存储在我的电脑里了，那我就可以使用CA的公钥进行解密操作，从而验证小美的证书是否是正确的了。 三胖：对的。我们可以使用你电脑里CA的公钥解密小美证书里的数字签名，从而得到签名的hash值。然后，你再用同样的hash算法对【小美的信息+公钥】进行hash计算。如果小美证书里签名的hash值与你自己计算出来的hash值一致，就说明这个证书确实是小美的，否则就不是小美的证书。 小二：三胖哥，我算是明白了。https还真是麻烦，但也确实保护了我的隐私。 三胖：对，有失必有得嘛！ 小二：嗯嗯。我现在通过小美的证书安全的获取了小美的公钥。那我这儿随机生成一个对称加密的秘钥，这个对称加密的秘钥再通过小美的公钥加密后，就能安全的传输给小美了。 三胖：是，小美再用他的私钥解密，就获取了你们约定的对称加密的密码了。以后，你们就可以使用对称加密来传输数据，暗送秋波了，哈哈~ 小二：三胖哥真是太厉害了，从此再也不用担心跟我女朋友聊天被恶搞了。 三胖：哈哈。你把你自己想成浏览器，把小美想成服务器。这就是整个https的传输流程。 小二：明白了，我画一下https在浏览器与服务器之间的运行流程，三胖哥你看下对不对。 三胖：不错不错，小二很厉害嘛，基本就是这个流程。 小二：没有没有，还得多谢三胖哥的指教啊，哈哈。 5. Charles抓取Https包的原理 三胖：小二，我们知道charles抓包工具能够抓取https的包，你知道这是什么原理吗？ 小二：这我还真不知道，按理说https是绝对安全的协议，内容不会被charles抓取啊。 三胖：你记不记得，使用charles抓https的包的时候，需要在你手机或电脑上安装并信任charles证书？ 小二：对对，是有这一步操作。 三胖：就是这一步操作，可以使Charles抓取你的https包。我给你画个流程图你就明白了。 小二：原来是这样，这不就是我刚才说的问题嘛。那么就说明https不是安全协议了？ 三胖：不是的。因为你安装并信任charles证书，是你自己主动的操作，也可以说是你自己主动泄密的结果。如果你不信任该charles证书，那么数据就不会被传输，连接会被直接中断。所以https还是安全的协议。 小二：我明白了，确实是这样，多谢三胖哥。 6. Happy Donehttps的原理明白了，接下来的事情自然就水到渠成了。 小二列出了接下来要做的事情： 1、向CA(公证处)申请自己网站的证书； 2、修改代码里静态资源的http链接为https链接； 3、修改ajax里面的http链接为https链接； 4、将证书部署在nginx上； 5、自测完成。 按照这个列表，小二一步步的顺利完成了。 最终，https上线完成，惬意的享受午后的阳光吧，happy done~","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]},{"title":"could not autowire no beans of type found spring boot","slug":"could not autowire no beans of type found spring boot","date":"2017-01-14T12:15:57.000Z","updated":"2018-04-14T12:27:19.772Z","comments":true,"path":"2017/01/14/could not autowire no beans of type found spring boot/","link":"","permalink":"http://www.xincc.top/2017/01/14/could not autowire no beans of type found spring boot/","excerpt":"","text":"spring boot自动装载的类总是报红，虽然不影响，但是很不舒服，看了网上的答案，一种降低报警等级，error改成warn，这肯定不行啊，还有一个face删除spring，这也不好吧，担心潜在的问题，starkoverflow看了一下，发现一个比较好的答案，就是自动装载的类加上注解@Repository 记得不是很清楚了，搞android很久了，我记得以前自动装载的类就要加这个注解的吧？不加也很正常，spring boot集成mybatis @Repositorypublic interface YourRepository","categories":[{"name":"java","slug":"java","permalink":"http://www.xincc.top/categories/java/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.xincc.top/tags/spring-boot/"},{"name":"java","slug":"java","permalink":"http://www.xincc.top/tags/java/"}]}]}